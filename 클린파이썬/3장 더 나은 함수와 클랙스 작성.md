# 3장 더 나은 함수와 클래스 작성

함수와 클래스는 파이썬 언어의 핵심 부분이다.  이번장에서는 코드를 더 읽기 쉽고 명확하게 만드는데 도움이 되는 사례를 알아보자.  
  
함수와 클래스를 작성하는 동안 함수/클래스의 경계 및 구조를 생각하는 것이 중요하다.  함수나 클래스가 해결하려고 하는 사용 사례를 명확하게 이해하면 더 나은 클래스와 함수를 작성하는 데 도움이 된다.  

## 함수

파이썬에서는 일반적으로 def 절에 코드를 작성할 때, 이를 함수나 메서드로 정의한 것이다. 

### 작은 함수 생성
함수를 작성할때는 보통 하나의 작업만 수행하는 함수를 작성하자.  

```python
import re

def get_unique_emails(file_name):
    """
    파일 데이터를 읽어 모든 고유 이메일을 가져온다.
    """
    emails = set()
    with open(file_name) as fread:
        for line in fread:
            match = re.findall(r'[\w\.-]+', line)
            for email in match:
                emails.add(email)
    return emails
```
위 예제에서 get_unique_emails는 두 개의 서로 다른 작업을 수행하고 있는데, 우선 각 라인을 읽기 위해 주어진 파일을 불러오고,   
그다음에는 각 라인의 이메일과 일치하는지 확인하기 위해 regex를 수행 한다.  
이 함수는 두개의 개별함수로 나눠서 작성하는 것이 더 가독성이 좋다.  하나는 파일을 불러오는 함수, 다르 하나는 파일의 내용을 확인하는 함수로 나눠보자.

```python
import re

def get_unique_emails(file_name):
    """
    이메일을 가져오는 코드
    """
    emails = set()

    for line in read_file(file_name):
        match = re.findall(r'[\w\.-]+', line)
        for email in match:
            emails.add(email)
    return emails

def read_file(file_name):
    """
    파일을 읽고 각 라인을 yield한다.
    """

    with open(file_name) as fread:
        for line in fread:
            yield line
```
함수 read_file은 모든 파일명을 확인하여 제너레이터를 만들어 주는 함수이고, get)unique_emails는 각 파일에서 이메일을 가져오는 함수이다.  
---  

함수를 작성 할 때는 먼저 구현하고자하는 함수를 작성하고, 이후 코드의 가독성을 고려하는 코드를 작성핟록 하자.

## 제너레이터 반환
위 예제에서 list나 tuple과 같은 특정 데이터 구조를 사용하는 대신 yield를 사용한다. 여기서 다른 데이터 구조를 사용하지 않은 이유는 파일의 크기가 얼마나 큰지 확실하지 않고 큰 파일을 처리하게되면 메모리가 부족할 수 있기 때문이다.  

### 제너레이터의 장점

- 제너레이터가 함수를 호출하면, 전체 함수를 실행하는 대신 이터레이터를 즉시 반환하고 루프 또는 리스트 변환과 같은 다른 작업을 수행할 수 있으며 코드를 익고 이해하기 쉽게 만든다.
- 리스트나 또 다른 데이터 구조에서 데이터가 크면 메모리 충돌이 발생할 수 수있다. 그러나 제너레이터는 그런 문제에 대해서 걱정할 필요가 없다. 따라서 처리할 데이터가 많거나 사전에 데이터의 크기가 확실하지 않은 경우에는 다른 데이터 구조 대신 제너레이터를 사용하자.  

```python
import re

def get_unique_emails(file_name):
    """
    이메일을 가져오는 코드
    """
    for line in read_file(file_name):
        match = re.findall(r'[\w\.-]+', line)
        for email in match:
            yield email
    

def read_file(file_name):
    """
    파일을 읽고 각 라인을 yield한다.
    """

    with open(file_name) as fread:
        for line in fread:
            yield line

def print_email_list():
    """
    이메일 리스트를 출력한다.
    """
    for email in get_unique_emails('duplicate_emails'):
        print(email)
```
위와 같이 코드를 작성하게 되면 메모리 이슈를 사전에 방지할 수 있다.  
하지만 모든 함수에 제너레이터를 사용하라는 것은 아니다. 만약 특정 데이터의 크기를 사전에 알고 있다면, 제너레이터 대신 다른 데이터 타입을 사용하는것이 더 쉬울 수 있다.  


## None 반환 대신 예외 발생  
이번절에서는 함수에서 None를 반환하는 것 대신 오류가 존재하는 경우 예외를 발생시키는 것을 다룬다. 우선 예외 발생시 몇가지 고려사항을 알아보자.  
많은 코드에서 예기치 않은 문제가 발생하면 None를 반환하거나 무언가를 로깅하는 것을 본적이 있을 것이다. 하지만 이러한 방법은 때때로 버그를 숨길 수 있기 때문에 위험하다.   

또한 예외를 발생 시키는 대신 None이나 일부 임의의 값을 반환하는 코드는 `호출 함수`의 혼동을 초래하고 오류가 발생할 가능성이 높다.  

```python
def read_lines_for_python(file_name, file_type):
    if not file_name or file_type not in('txt','html):
        return None
    
    line = []
    with open(file_name, 'r') as fileread:
        for line in fileread:
            if 'python' in line:
                return 'Found Python"

if not read_lines_for_python('file_without_python_name', 'pdf'):
    print("not correct file format or file name dosen't exist")
```

위 예제에서는 파일에 파이썬 단어나 파일 관련 문제가 없으므로 `read_lines_for_python`이 None을 반환하는지 확신할 수 없다. 이러한 종류의 코드는 예기치 않은 버그를 유발할 수 있으며, 엄청 긴 코드에서는 버그를 찾기가 어려울 수 있다.  
따라서 코드를 작성할 때 예기치 않은 문제가 생겨서 None이나 다른 값을 반환하는 상황이 발생하면 예외 발생을 고려하자. 버그를 쫓는 시간을 절약할 수 있을 것이다.  

```python
def read_lines_for_python(file_name, file_type):
    if file_type not in ("txt", "html"):
        raise ValueError("Not correct file format")
    if not file_name:
        raise IOError("File Not Found")

    with open(file_name, "r") as fileread:
        for line in fileread:
            if "python" in line:
                return "Found Python"


if not read_lines_for_python("file_without_python_name", "pdf"):
    print("Python keyword doesn't exists in file")

# Result:  >> ValueError("Not correct file format")
```
코드 실행에서 오류가 발생할 때마다 예외가 발생한 이유를 살펴보면 디버깅을 빠르게 할 수 이을 것이다. 어떤 버그일지 추측하는 대신 예외를 발생시키자.  
---
파이썬은 동적 언어이므로 코드를 작성할 때, 특히 코드에서 예상치 못한 값을 반활할때 주의해야 한다. 함수에서 반환된 기본값은 None이지만, 예기치 않은 상황마다 이를 남용하지 말자.  None을 반환하는 코드를 작성하기 전에 예외 처리를 적용 할 수 있는지 먼저 고민하자.  

## default 및 keyward argument를 사용한 행동 추가  

 keyword argument는 파이썬 코드를 더 읽기 쉽고 깔끔하게 만드는데 유용하다.  keyword argument는 함수 호출 시 사용하거나 함수의 키워드로 사용할 수 있다.

 ```python
def calculate_sum(first_number=5, second_number=10):
    return first_number + second_number

calculate_sum()
calculate_sum(50)
calculate_sum(90, 10)
 ```
 
 여기서 keyward augment를 사용해 기본값을 정의했지만, 함수를 호출하는 동안 기본값이나 사용자 정의 값이 필요한지 선택 할 수 있다.  

 keyward augment의 유용성은 큰 코드 베이스나 여러 인자를 가진 함수에서 중요하다.  
 아래 예제 처럼 이메일 콘텐츠에 키워드를 사용해 스팸 메일을 찾아야 하는 예제를 살펴보자.  
 ```python
def spam_emails(from, to, subject, size, sender_name, receiver_name):
    <code code code>
 ```
 키워드 인자 없이 spam_emails 를 호출 하는 경우는 아래와 같다.

 ```python
spam_emails('ab_from@gmail.com','nb_to@naver.com','is email spam',10000,'an','bd')
 ```

 위 코드를 보면 매개변수가 함수에 어떤 의미인지 한번에 추측하기 어렵다. 많은 매개변수가 함수를 호출 하는데 사용 되는 것을 볼려면 아래 처럼 keyward augment를 사용하는 것이 좋다.

```python
spam_emails(from = 'ab_from@gmail.com',to = 'nb_to@naver.com',subject= 'is email spam',size = 10000,to = 'an',from = 'bd')
 ```

## 명시적인 None 반환 금지
명시적으로 반환하지 않으면 기본적으로 파이썬 함수는 None를 반환한다.아래 예제를 살펴 보자

 ```python
def sum(first_number, second_number):
    sum = first_number + second_number

sum(80,90)
 ```
 여기서 sum 함수는 기본적으로 None를 반환한다. 하지만 많은 경우 사람들은 아래 예제 처럼 함수에서 None를 명시적으로 반환하는 코드를 작성한다.

 ```python
def sum(first_number, second_number):
    if isinstance(first_number, int) and isinstance(second_number, int):
        return first_number + second_number
    else:
        return None


result = sum(10, "str")           # Return None
result = sum(10, 5)			 # Return 15
 ```
여기서 결과는 함수 sum의 값으로 예상할 수 있는데, None이나 두 숫자의 합을 반환할 수 있기 때문에 오해의 소지가 있다. 따라서 항상 None에 대한 결과를 확인할 필요가 있는데, 이는 시간이 지남에 따라 코드를 더 복잡하게 만든다.  
이 경우 예외를 발생 시켜 코드를 수정해 보자.

```python
def sum(first_number, second_number):
    if isinstance(fist_number, int) and isinstance(second_number, int):
        return first_number + second_number
    else :
        raise ValueError("Provide only int values")
```

## 방어적인 함수 작성
프로그래머는 언제든 오류에 빠질 수 있으므로, 코드를 작성할 때 실수하지 않을 것이라고 보장할 수 없다.   
이러한 사실을 감안하여 프로덕션으로 이동하기 전에 코드의 버그를 예방하거나 노출시킬 수 있는 함수나 프로덕션에서 버그를 찾을 수 있도록 도와주는 함수를 작성해 선제적으로 조치를 취하자.  
프로그래머가 코드를 프로덕션으로 이동하기 전에 코드 품질을 확실하게 하고자 할 두 가지 작업 이있다. 
- 로깅
- 단위 테스트

### 로깅
로깅은 코드 디버깅을 시도할 때, 특히 문제가 진행되는 위치를 사전에 알 수 없는 경우 프로덕션에서 크게 도움이 될 수 있다. 
성숙한 프로젝트, 특히 중대형 프로젝트에서는 로깅 없이 프로젝트를 오랫 동안 유지/관리 하기 어렵다.  
코드에서 로깅을 진행하면, 프로덕션 문제가 발생할 경우 코드를 훨씬 쉽게 디버깅하고 진단할 수 있다.   
아래 예제 처럼 로깅 코드가 일반적으로 보이는 방법을 살펴 보자.  

```python
# Import logging module
import logging

logger = logging.getLogger(__name__)          # Create a custom logger
handler = logging.StreamHandler()             # Using stream handler

# Set logging levels
logger.setLevel(logging.WARNING)
logger.setLevel(logging.ERROR)

format_c = logging.Formatter("%(name) - %(levelname) - %(message)")
handler.setFormatter(format_c)               # Add formater to handler
logger.addHandler(handler)

def division(divident, divisor):
    try:
        return divident/divisor
    except ZeroDivisionError:
        logger.error("Zero Division Error")

num = division(4, 0)
```

파이썬에는 포괄적이고 사용자 정의 가능한 logging 모듈이 있으며, 코드에서 다양한 수준의 로깅을 정의할 수 있다.  
 프로젝트에서 여러 타입의 오류가 존재하는 경우 상황으이 심각도에 따라 해당 오류를 로깅할 수 있다. 예를 들어, 사용자 계정을 생성시 발생하는 오류는 이메일 전송의 실패 오류 보다 더 심각하다.  
파이썬 logging 모듈은 필요에 따라 로깅을 구성할 수 있는 다양한 기능을 제공하는 라이브러리이다.


### 단위 테스트
단위 테스트는 코드에서 가장 중요한 부분 중 하나다. 실무적으로 코드에서 단위 테스트를 의무화하면, 버그 발생을 에방할 수 있고 프로덕션 환경으로 전환하기 전에 코드에 대한 자신감을 가질 수 있다. 파이썬에는 단위 테스트를 쉽게 작성할 수 있는 훌륭한 라이브러리가 많다. 그중 unittest 라이브러리와 py.test 라이브러리를 간단히 알아보자.    


```python
import unittest

def sum_numbers(x, y):
    return x + y

class SimpleTest(unittest.TestCase):
    def test(self):
        self.assertEqual(sum_numbers(3,4), 7)


#py.test
def sum_numbers(x, y):
    return x + y

def test_sum_numbers():
    assert func(3, 4) == 7
```
단위 테스트의 역할
- 단위 테스트를 코드의 문서로 사용할 수 있는데, 이는 코드를 다시 살펴보거나 새로운 개발자가 프로젝트에 참여할 때 매우 유용하다.  
- 단위 테스트는 코드에서 예상되는 동작을 수행한다는 확신을 줄 수 있다. 함수에 대한 테스트가 있을 때 코드를 변경해도 함수가 중단되지 않도록 할 수 있다.  
- 프로덕션으로 전환하기 전에 단위 테스트를 실행하기 때문에 오래된 버그가 코드에 들어가지 않도록 할 수 있다.

---
프로젝트에서 로깅과 단위 테스트는 필수이며, 코드의 버그를 예방하는 데 크게 도움이 될 수 있다.  


# 클래스 

## 클래스의 올바른 크기

어떤 언어든지 객체지햔 프로그래밍을 하고 있다면 클래스의 올바른 크기가 무엇인지 궁금할 것이다.  

클래스를 작성할 때는 항상 `단일 책임 원칙(SRP)`을 기억하자. 명확하게 정의된 경계를 갖고 명확하게 정의된 책임을 가진 클래스를 작성하는 경우에는 클래스 코드 라인에 대해 걱정할 필요가 없다.  어떤 사람들은 하나의 파일로 이뤄진 하나의 클래스가 좋은 클래스라고 생각한다. 그러나 파일 자체가 눈에 띄게 큰 코드를 봤는데, 파일 당 하나의 클래스를 보는 것은 혼란스럽고 오해의 소지가 있을수있다.      

<br/>  

각 메서드와 코드 라인을 주의 깊게 살펴보고 해당 메서드나 코드의 일부가 클래스의 전반적은 책임에 적합한지를 생각하는 것이 클래스 구조를 조사하는 좋은 방법이다.  

코드르 작성하기 전에 클래스 범위를 명확하게 정의하면 대부분 클래스 크기 문제를 해결할 수 있을 것이다.  

## 클래스 구조
필자는 아래 순서의 클래스 구조를 선호 한다.  

1. 클래스 변수
2. __init__
3. 내장 파이썬 특수 메서드(__call__, __repr__등)
4. 클래스 메서드
5. 정적 메서드
6. 속성
7. 인스턴스 메서드
8. 프라이빗 메서드 

```python
import datetime

class Employee(Person):
    POSITIONS = ("Superwiser", "Manager", "CEO", "Founder")

    def __init__(self, name, id, department):
        self.name = name
        self.id = id
        self.department = department
        self.age = None
        self._age_last_calculated = None
        self._recalculated_age()

    def __str__(self):
        return ("Name: " + self.name + "\nDepartment: "
               + self.department)
        
    @classmethod
    def no_position_allowed(cls, position):
        return [t for t in cls.POSITIONS if t != position]

    

    @staticmethod
    def c_positions(cls, position):
        return [t for t in cls.TITLES if t in position]

    @property
    def id_with_name(self):
        return self.id, self.name

    def age(self):
        if (datetime.date.today() > self._age_last_recalculated):
            self._recalculated_age()
        return self.age


    def _recalculated_age(self):
        today = datetime.date.today()
        age = today.year - self.birthday.year
        if today < datetime.date(
           today.year, self.birthday.month,
           self.birthday.year):
           age -= 1
	    
        self.age = age
        self._age_last_recalculated = today
```

- 클래스 변수
    - 클래스 변수는 상수나 기본 인스턴스 변수 이므로 일반적으로 최상위에 클래스 변수를 표시하는 것을 추천한다. 
- \_\_init__
    - \_\_init\_\_ 는 클래스르 호출하는 방법과 클래스에 속한 상태를 알려주는 모든 클래스의 관문을 나타낸다. 또한 \_\_init\_\_ 는 클래스의 사용을 시작하기 전에 제공할 클래스의 주요 입력에 대한 정보도 제공한다.

- 특수 파이썬 메서드
    - 특수 메서드는 클래스의 기본 동작을 변경하거나 클래스의 추가 기능을 제공하므로 클래스 최상위에 있는 클래스 리더가 클래스의 일부 사용자 정의 기능을 인식하게 한다. 특수 메서드를 최상위에 두면, 사용자는 클래스 코드의 나머지 부분을 읽기 전에 클래스의 수정된 동작을 염두에 둘 수 있다.  

- 클래스 메서드
    - 클래스 메서드는 다른 생성자로 작동하므로 \_\_init\_\_ 근처에 유지하는 것이 옳다. \_\_init\_\_를 사용해 생성자를 생성하지 않고 클래스를 사용할 수 있는 다른 방법을 개발자에게 알려준다.  
- 정적 메서드
    - 정적 메서드는 클래스 메서드와 같은 클래스의 객체가 아니라 클래스에 바인딩된다. 클래스 상태를 수정할 수 없으므로 특정 목적에 사용되는 메서드를 인식하기 위해 정적 메서드를 상단에 추가하는 것이 좋다.  

- 인스턴스 메서드
    - 인스턴스 메서드는 클래스의 동작을 추가하므로, 개발자는 클래스가 특정 동작을 갖고 있는 경우 인스턴스 메서드가 클래스의 일부가 될 것으로 예상한다. 따라서 특수 메서드로 유지하면 코드를 더 쉽게 이해할 수 있다.
- 프라이빗 메서드
    - 파이썬은 private 키워드 개념이 없으므로, 메서드 이름에 \_\<name>를 사용하면 독자에게 이것이 private 메서드임을 알려준다. 이는 인스턴스 메서드로 최하단에 유지할 수 있다 .  

코드르 쉽게 이해할 수 있도록 인스턴스 메서드 주위에 private 메서드를 유지하는 것이 좋다. 인스턴스 메서드 전에 private 메서드를 가질 수 있으며, 그 반대도 가능하다. 호출된 메서드에 가장 가까운 메서드를 호출 하는 것이다.

## @property를 사용하는 올바른 방법

@property 데코레이터는 값을 가져오고 설정하는 데 유용한 파이썬 기능 중 하나다.  
클래스에는 @property 사용을 고려할 수 있는 두가지 위치가 있다. 하나는 속성 뒤에 숨겨진 복잡한 코드 안이고, 다른 하나는 set속성의 유효성 검사 내부다. 아래 예제를 살펴보자.

```python
class Temperature:

    def __init__(self, temperature = 0):
        self.temperature = temperature

    @property
    def fahrenheit(self):
        self.temperature = (self.temperature * 1.8) + 32
temp = Temperature(10)
temp.fahrenheit
print(temp.temperature)
```

이 코드의 문제점은 무엇인가? fahrenheit 메서드에서 속성 데코레이터르 사용하고 있지만, 메서드는 어떠한 값을 반환하는 대신 self.temperature 변수 값을 수정한다. 속성 데코레이터를 사용할 때는 값을 반환해야 한다. 이로써 속성 데코레이터를 사용할 때 호출 클래스/메서드에서 메서드로부터 반환되는 것을 더 쉽게 기대할 수 있다. 따라서 아래 예제 처럼 값을 반환하자.

```python
class Temperature:

    def __init__(self, temperature = 0):
        self.temperature = temperature

    @property
    def fahrenheit(self):
        return self.temperature = (self.temperature * 1.8) + 32
```

속성 데코레이터는 값의 유효성을 확인/필터링하는 데도 사용되며, 자바와 같은 다름 프로그래밍 언어의 세터와 도일하다. 파이썬에서는 속성 데코레이터를 사용해 특정 정보의 유효성을 확인/필터링 할 수 있다. 
속성 데코레이터를 적절하게 사용하면 코드가 읽기 쉬워지며 때때로 잊어 버리는 corner bug에서 벗어날 수 있다.  

아래 예제는 화씨를 온도로 설정하는 Temperature라는 클래스가 있고 송성 데코레이터를 사용해 온도 값을 얻고 설정하면 Temperature 클래스가 호출자 입력을 좀 더 쉽게 할 수 있다.

```python
class Temprature:
    def __init__(self, temprature=0):
        self.temprature = temprature

    @property
    def fahrenheit(self):
        return self._temprature
    
    @fahrenheit.setter
    def fahrenheit(self, temp):
        if not isinstance(temp, int):
            raise("Wrong input type")

        self._temprature = (self.temp * 1.8) + 32
```
fahrenheit 세터 메서드는 화씨 온도를 계산하기 전에 유효성 검사를 수행하므로, 호출 클래스에서는 잘못된 입력의 경우 예외가 발생할 수 있다. 호출 클래스는 입력 없이 fahrenheit 메서드를 호출해 화씨 값을 얻는다.  

항상 올바른 컨텍스트에서 속성 키워드들을 사용하고, 그 키워드들을 파이써닉 방식으로 코드를 작성해 게터와 세터로 간주한다.  

## 정적 메서드 사용 시기

정의에 따르면, 정적 메서드는 클래스와 관련이 있자만 클래스마다 특정 데이터에 액세스할 필요 없다. 정적 메서드에서는 self나 cls를 사용하지 않는다. 이러한 메서드는 클래스 상태에 대한 종속성 없이 자체적으로 실행 시킬 수 있다. 이것이 독립형 함수 대신 정적 메서드를 사용할 때 혼돈을 일으키는 주 원인 이다.  

클래스를 작성할 때 함수로서 단독으로 존재할 수 있고 특정 행동을 수행하기 위해 클래스 상태가 필요하지 않은 메서드가 있을 수 있다. 때로는 클래스의 일부분으로 정적 메서드를 사용할 수 있다. 하지만 왜 클래스 외부에서 독립 함수를 만들지 않냐 하면, 클래스 내부에 메서드를 유지하면 해당 함수를 클래스와 쉽게 연관시킬 수 있다.

```python
# 정적메서드 미사용
def price_to_book_ratio(market_price_per_share, book_value_per_share):
    return market_price_per_share/book_value_per_share

class BookPriceCalculator:
    PER_PAGE_PRICE = 8

    def __init__(self, pages, author):
        self.pages = pages
        self.author = author

    @property
    def standard_price(self):
        return self.pages * PER_PAGE_PRICE

# 정적 메서드 사용

class BookPriceCalculator:
    PER_PAGE_PRICE = 8

    def __init__(self, pages, author):
        self.pages = pages
        self.author = author

    @property
    def standard_price(self):
        return self.pages * PER_PAGE_PRICE


    @staticmethod
    def price_to_book_ratio(market_price_per_share, book_value_per_share):
        return market_price_per_share/
```
여기서 price_to_book_ration 메서드는 BookPrice Calculator 상태를 사용하지 않고도 작동할 수 있지만, BookPriceing 클래스와 관련돼 있으므로 BookPriceCaculator 클래스 내에 유지하는 것이 좋다. 

## 파이써닉 방법의 추상 클래스 상속 사용

추상화는 파이썬의 멋진 기능 중 하나이며, 상속된 클래스가 예상대로 구현되도록 하는 데 도움을 준다. 인터페이스에서 추상 클래스를 보유하는 주요 목적은 무엇일까?

- 추상화를 사용해 인터페이스 클래스를 만들 수 있다.
- 추상 메서드를 구현하지 않으면 인터페이스 사용을 불가능하게 할 수 있다.
- 추상 클래스 규칙을 준수하지 않으면 초기 오류가 발생한다.

파이썬에서 잘못된 방식으로 추상화를 구현하면 이러한 장점이 OOPS 추상화 규칙을 위반 할 수 있다.  

```python
# 잘못된 방법의 추상 클래스

from abc import ABCMeta, abstractmethod

class Fruit(metaclass=ABCMeta):

    @abstractmethod
    def taste(self):
        raise NotImplementedError()

    @abstractmethod
    def originated(self):
        raise NotImplementedError()


class Apple:
    def originated(self):
        return "Central Asia"


fruit = Fruit()
fruit.originated() # Central Asia
fruit.taste() # NotImplementedError
```


위 코드의 문제점은 다음과 같다.
- Apple 또는 Fruit 클래스를 오류 없이 초기화할 수 있다. 클래스의 객체를 생성하자마자 예외가 발생했을 것이다.
- 또한 해당 코드는 taste 메서드를 사용할 때까지 불완전한 클래스라는 것을 인식하지 못한 채 프로더션으로 이동했을 수 있다.


```python
from abc import ABCMeta, abstractmethod

class Fruit(metaclass=ABCMeta):

    @abstractmethod
    def taste(self):
        pass

    @abstractmethod
    def originated(self):
        pass


class Apple:
    def originated(self):
        return "Central Asia"


fruit = Fruit()
"""
TypeError:
"Can't instantiate abstract class Fruit with abstract methods originated, taste"
"""
```

abc 모듈을 사용해 모든 예상되는 메서드를 구현하고, 유지 보수 가능한 코드를 제공하며, 프로덕션에 섣부른 코드 (half-baked code)가 없는지 확인한다.  

## private 대신 public 속성 사용

파이썬에는 클래스에 대한 private 속성 개념이 없다. 그러나 `dunder \_<var_name>` 변수 이름을 사용해 메서드를  private로 표시하는 코드를 사용했거나 본적이 있을 것이다. 하지만 여전히 이러한 변수에 액세스 할 수 있지만 금지된 것으로 간주 된다. 

이 사실을 고려하면, 여전히 코드를 번거롭고 불안정하게 만들 수 있기 때문에 원하는 모든 곳에서 클래스 변수의 사용을 자제할 것을 추천한다.  

private 인스턴스 변수로 \_full_name을 가진 Person 클래스가 있다고 가정하자. \_full|name 인스턴스 변수에 액세스하기 위해 get_name이라는 메서드를 생성했는데, 이 메서드는 호출자 클래스가 private 메서드에 직접 액세스하지 않고변수에 대한 액세스 권한을 부여 한다.  

```python
class Person:

    def __init__(self, first_name, last_name):
        self._full_name = f"${first_name} ${last_name}"

    def get_name(self):
        return self._full_name

per = Person("Larry", "Page")
assert per.get_name() == "Larry Page"
```

위 에제는 변수를 private로 만드는 잘못된 방법이다.  
보다시피 Person 클래스는 \_full_name으로 이름을 지정해 속성을 숨기려고 한다.   
하지만 코드의 의도가 \_full_name 변수에만 액세스하는 사용자를 제한하는 것일지라도, 코드를 훨씬더 번거롭고 읽기 어렵게 만든다.   
다른 모든 private 변수에 대해 이 작업을 고려하면 코드가 복잡해질 수 있다. 클래스에 private 변수가 많고 prviate 변수 만큼 메서드를 정의해야 하는 경우 어떻게 될까?  

<br/>  

파이썬은 변수와 메서드에 대한 private 액세스를 강제하지 않으므로 호출자 클래스 혹은 메서드에 노출하고 싶지 않을 때마다 클래스 변수나 메서드를 private으로 생성 한다.   
따라서 클래스 변수와 메서드를 pirvate로 생성하는 것은 이러한 메서드 또는 변수가 액세스되거나 재정의돼서는 안 되는 호출자 클래스 또는 메서드와 통신하는 방법이다.  

public 클래스를 상속하려고 할 때 해 당 public 클래스와 변수를 제어할 수 없는 경우 코드에 \__<var_name> 이름을 사용할 것을 추천한다.  

```python
class Person:
    def __init__(self, first_name, last_name):
        self.age = 50
        self.full_name = first_name + last_name

    def get_name(self):
        return self.full_name

class Child(Person):
    def __init__(self, first_name, last_name):
        super().__init__(first_name, last_name)
        self.__age = 20


ch = Child("Larry", "Page")
print(ch.age)              # 50
print(ch._Child__age)      # 20
```


## 요약 

파이썬은 자바와 같은 다른 프로그래밍 언어 처럼 변수/메서드나 클래스에 대한 액세스 제어가 없다.   
파이썬은 모든 변수를 public으로 생각하지만, 실제로는 private 개념과 public 개념을 사용자들끼리 암묵적으로 합의하여 사용한다.  