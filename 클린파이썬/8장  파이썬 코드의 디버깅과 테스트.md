# 파이썬 코드의 디버깅과 테스트

## 디버깅
디버깅은 개발자에게 가장 중요한 기술 중 하나다. 디버깅은 개발 프로세스를 모두 마친 후에 수행돼서는 안 된다. 

### 디버깅 도구

### pdb
pdb는 파이썬 코드를 디버깅하는데 가장 유용한 command line 도구 중 하나다.  
pdb는 스택 정보와 매개변수 정보를 제공하고 pdb 디버거 내의 코드 명령으로 이동한다.  
파이썬 코드에서 디버거를 설정하기 위해 다음과 같이 작성할 수 있다.  

```python
import pdb
pdb.set_trace()
```
pdb 디버거가 사용 가능한 라인에 제어가 도달하면 pdb 명령줄 옵션을 사용해 코드를 디버깅 할 수 있다.  pdb는 다음 명령을 제공한다.  

- h : 도움말 명령
- w : 스택 트레이스(stack trace) 출력
- d : 현재 프레임 카운트를 아래로 이동
- u : 현재 프레임 카운트를 위로 이동 
- s : 현재 라인 실행
- n : 다음 라인까지 계속 실행
- unt [라인번호] : 라인 번호까지 계속 실행
- r : 현재 함수가 반환될 때까지 계속 실행

### ipdb
pdb와 유사하게 ipdb는 디버거 command line 도구다.  IPython의 ipdb를 사용할 수 있다는 추가 이점으로  
pdb와 동일한 기능을 제공한다. 다음과 같이 ipdb 디버거를 추가할 수 있다.  

```python
import ipdb
pdb.set_trace()
```

설치되면 ipdb에서 사용 가능한 모든 명령을 확인할 수 있다. 다음과 같이 대부분 pdb와 유사하다.  
- h : 도움말 명령
- w : 스택 트레이스(stack trace) 출력
- d : 현재 프레임 카운트를 아래로 이동
- u : 현재 프레임 카운트를 위로 이동 
- s : 현재 라인 실행
- n : 다음 라인까지 계속 실행
- unt [라인번호] : 라인 번호까지 계속 실행
- r : 현재 함수가 반환될 때까지 계속 실행

### pudb
pudb는 pdb와 ipdb보다 더 많은 기능을 가진 풍부한 디버깅 도구이며, 콘손을 기반으로 하는 시각적 디버거다. 
pdb나 ipdb와 같은 명령줄로 이동하는 대신에 코드를 작성할 때 코드를 디버깅할 수 있다. GUI 디버거처럼 보이지만, 콘손에서 실행되므로 GUI 디버거에 비해 가볍게 만들어졌다.  

```python
import pudb
pudb.set_trace()
```
pudb 단축키
- n : 다음 명령 실행
- s : 함수의 다음 단계
- c : 계속 실행
- b : 현재 라인 브레이크포인트 설정
- e : 넘겨진 예외의 트레이스백 표시
- q : 실행 중인 프로그램의 종료나 재시작을 위한 대화상자 오픈
- o : 원래 콘솔/표준 출력 화면 표시
- m : 다른 파일 모듈 오픈 
- L : 라인 이동
- ! : 화면 하단의 파이썬 명령줄 하위 창으로 이동
- ? : 전체 단축키 명령 리스트가 포함된 도움말 대화상자 표시
- <SHIFT + V> : 컨텍스트를 화면 오른쪽의 변수 하위 창으로 전환
- <SHIFT + B> : 컨텍스트를 화면 오른쪽의 브레이크 포인트 하위 창으로 전환
- <CTRL + X> : 코드 라인과 파이썬 명령중 간의 컨텍스트 토글

 예를 들어, pudb 화면에서 b를 누르면 c바로가기로 진행 후 실행이 중지되는 해당 라인에 브레이크 포인트가 설정 된다. 


## breakpoint
breakpoint는 파이썬 3.7에서 도입된 새로운 키워드이며 코드를 디버깅하는 기능을 제공한다.  

```python
x = 10
breakpoint()
y = 20
```
breakpoint() 함수가 호출될 메서드를 디버거에 제공하기 위해 PYTHONBREAKPOINT 환경 변수를 사용해 breakpoint를 구성할 수도 있다. 

## 프로덕션 코드 출력 대신 logging 모듈 사용

파이썬에는 로그를 기록하는 logging이라는 라이브러리가 있다.  
로깅은 코드의 흐름을 이해하는데 도움이 된다. 로깅이 사용 가능하자면, 스택트레이스르 제공해 오류가 발생한 위치를 알 수 있다.  


```python
# 로깅 사용 법
import logging
logging.getLogger(__name__).addHandler(logging.NUllHandler())
```

```python
import logging
from logging.config import dictConfig

loggigng_config = dict(version = 1,
                        formatter = {'f': {'format' : "%(asctime)s %(name) -12s %(levelname) -8s %(message)s"}},
                        handlers = {
                            'H':{'class' : 'logging.StreamHandler',
                            'formatter' : 'f',
                            'level' :logging.DEBUG,
                            }
                        },
                        root = {'handlers' :['h'], 'level' :logging.DEBUG}
)

dictConfig(logging_config)

logger = logging.getLogger()
logger.debug('This is debug logging')
```
로그의 전체 스택 트레이스를 캡쳐 하자.
```python
import logging
a = 90
b = 0
try : 
    c = a / b
except Exception as e:
    logging.error('Exception ', exc_info = True)
```

## 로깅 클래스와 함수
logging 모듈에는 나만의 로깅 클래스를 정의하고 특정 요구와 프로젝트의 로깅을 구성하는 데 사용할 수 있는 많은 클래스와 함수가 있다.    

<br/>  

- Logger: logging 모듈의 일부이며 logger 객체를 얻기 위해 애플리케이션에서 직접 호출된다. 다음과 같은 여러 메서드가 있다.
    - setLevel : 로깅 레벨을 설정. 로거가 생성되면 NOSET으로 설정
    - isEnableFor : 이 메서드는 loggigng.disable(level)에 의해 설정된 로깅 레벨을 확인
    - debug : 로거의 DEBUG 레벨로 메시지를 로깅
    - info : 로거의 INFO로 메시지를 로깅
    - waring : 로거의 WARING으로 메시지를 로깅
    - error : 로거의 ERROR 레벨로 메시지를 로깅
    - critical : 로거의 CRITICAL 레벨로 메시지를 로깅
    - log : 로거의 정수 레벨로 메시지 로깅
    - exception : 로거의 ERROR 레벨로 머시지를 로깅
    - addHandler : 로거의 특정 핸들러를 추가 
- Handler : Handler는 StreamHandler, FileHandler, SMTPHandler, HTTPHandler 등과 같은 기타 유용한 핸들러 클래스의 기본 클래스다. 이 서브클래스들은 `sys.stdout`이나 디스크 파일과 같은 것을 대상으로 로깅 출력을 전송함.
    - creatLock:기본 I/O 기능을 위한 액세스를 직렬화하는 데 사용할 수 있는 스레드 잠금을 초기화한다.
    - setLevel : 핸들러를 레벨로 설정한다.
    - flush : 로깅 출력이 플러시(flush) 되도록 한다.
    - clos : Handler의 서브클래스는 재정의된 close() 메서드에서 호출되도록 한다.
    - format: 출력 로깅의 형식을 정의한다.
    - emit: 실제로 특정 로깅 메시지를 로깅한다. 
- Formatter : 출력에 포함되는 속성을 나열하는 문자열 형식을 지정해 출력 형식을 지정한다. 
    - format: 문자열을 형식화한다.
    - formatTiem : 시간을 형식화한다. time.strftime()과 함께 사용해 레코드 생성 시간을 형식화한다. 
    - formatException : 특정 예외 정보를 형식화한다.
    - formatStack : 문자열의 스택 정보를 형식화한다.


```python
import logging
import logging.config

logging.config.fileConfig(fname='logging.conf', disable_existimg_loggers = False)

# 파일의 지정된 로거를 얻는다.
logger = logging.getLogger(__name__)

logger.debug('Debug logging message')
```

```YAML
#YAML 로깅 파일
version: 1
formatters:
  simple:
    format: '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
handlers:
  console:
    class: logging.StreamHandler
    level: DEBUG
    formatter: simple
    stream: ext://sys.stdout
loggers:
  sampleLogger:
    level: DEBUG
    handlers: [console]
    propagate: no
root:
  level: DEBUG
  handlers: [console]
```
```python
import logging
import logging.config
import yaml

with open('logging.yaml', 'r') as f:
    config = yaml.safe_load(f.read())
    logging.config.dictConfig(config)

logger = logging.getLogger(__name__)

logger.debug('Debug logging message')
```

## 병목 현상 식별을 위한 메트릭 라이브러리 사용
메트릭은 코드 특정 부분의 오류 개수나 서드 파티 API의 응답 시간처럼 코드에서 다양한 데이터 포인트를 수집한다.  
메트릭은 웹 애플리케이션에서 현재 로그인한 사용자 수와 같은 특정 데이터 요소를 수집하도록 정의될 수 있다.  

<br/>  

메트릭은 일반적으로 시스템 오버타임을 모니터링하기 위해 요청당, 초당, 분당 한번씩이나 정기적 간격으로 수집된다.  
메트릭은 다양한 종류가 있으며 `성능 메트릭(performance metric)` 이나 `리소스 메트릭(resource metric)` 으로 분류할 수 있다.  

- 성능 메트릭
    - Throughput : 시스템이 단위 시간당 수행하는 작업량
    - Error : 단위 시간당 오류 결과의 수나 요류의 비율
    - Performance : 작업 단위를 완료하는 데 필요한 시간
- 리소스 메트릭
    - Utilization : 리소스가 사용 중인 시간의 백분율
    - Availability : 리소스가 요청에 응답한 시간

메트릭을 사용하기 전에 애플리케이션을 추적하는 데 사용할 데이터 포인트의 종류를 고려하자.  
메트릭을 사용하면 애플리케이션에 대한 확신이 높아지고 애플리케이션 성능을 측정할 수 있다.  

## 테스팅

모든 소프트웨어 애플리케이션의 경우, 테스트 코드를 갖고 있어야한다. 코드에 버그가 있는지 확인이 필요하기 때문이다.  

### 테스통이 중요한 이유
테스팅은 실제 코드만큼 중요하며, 테스팅으로 배포 코드가 예상대로 작동하는지 확인 할 수 있다.  
애플리케이션 코드의 첫 번째 라인을 작성하자마자 테스팅 코드 작성을 시작해야 한다.   
테스팅은 사후에 검토돼서는 안 되며 모든 코드가 예상된 동작을 하는지 확인해야 한다.   
<br/>

**테스트 작성을 고려해야 하는 이유**
- 코드 작성을 시작하자마자 테스팅 코드를 작성해야 한다. 테스트가 없다면 올바른 길로 가고있는지 확인이 어렵다.
- 주요 변경 사항을 조기에 감지. 코드의 한 부분을 변경하면 코드의 다른 부분이 손상될 가능성이 있다.
- 코드를 문서화하는 데도 중요한 역할을 한다. 테스트는 코드의 모든 부분 문서를 작성하지 않고도 코드를 문서화하는 데 매우 유용하다.  
- 새로운 개발자가 팀에 합류하면, 테스트를 실행하고 읽음으로써 코드에 익숙해지기 시작해 코드 흐름에 대한 아이디어를 얻을 수 있다. 

### Pytest와 UnitTest
Pytest와 UnitTest는 파이썬의 테스트 라이브러리이다.  
Pytest는 서드 파티 라이브러리이고, UnitTest는 파이썬의 기본 제공 라이브러리이다.  따라서 Pytest는 설치가 필요하다.

```python
from unittest import TestCase

class SimpleTest(TestCase):
    def test_simple(self):
        self.assertTrue(True)

    def test_tuple(self):
        self.assertEqual((1, 3, 4), (1, 3, 4))
    
    def test_str(self):
        self.assertEqual('This is unit test', 'this is')
```

```python
import pytest

def test_simpe():
    assert 2 == 2

def test_tuple():
    assert (1, 3, 4) == (1, 3, 4)
```

보다시피 UnitTest는 TestCase 인스턴스 메서드를 사용한다.  
하지만 Pytest는 기본으로 제공되는 assert가 있다. Pytest의 assert는 다른 assert 메서드에 대해 알지 못해도 읽기 쉽다.  
그러나 UnitTest assertion은 더 설정(configurable) 가능하며 assert를 위한 더 많은 메서드를 가지고 있다.

```python
from unittest import TestCase

class SimpleTest(TestCase):
    def not_equal(self):
        self.assertNotEqual(2, 3)

    def assert_false(self):
        x = 0
        self.assertFalse(x)

    def assert_in(self):
        self.assertIn(5, [1, 3, 8, 5])
```

```python
import pytest

def not_equal():
    assert 2 != 2

def assert_false():
    x = 0
    assert x is 0

def assert_in():
    assert 5 in [1, 3, 8, 5]
```
Pytest는 코드로 오류를 강조 표시하지만, UnitTest에는 해당 기능이 없다. 또한 강조 one-lie error가 표시된다. 향후 버전에서 변경될 수 있지만, 현재 Pytest는 더 나은 오류 보고 기능을 제공한다.   

<br/>  

Pytest에는 모듈, 세션, 함수를 구성할 수 있는 fixture 같은 setup method가 있다. UnitTest에는 setUp 메서드와 tearDown 메서드가 있다. 

```python
from unittest import TestCase


class SetupBaseTestCase(TestCase):
    def setUp(self):
        self.sess = CallClassBeforeStartingTest()
 
    def test_simple(self):
        self.sess.call_function()

    def tearDown(self):
        self.sess.close()
```

```python
import pytest


@pytest.fixture
def get_instance():
    s = CallClassBeforeStartingTest()
    s.call_function()
    return s


@pytest.fixture(scope='session')
def test_data():
    return {"test_data": "This is test data which will be use in different test methods"}


def test_simple(test_data, test_instance):
    assert test_instance.call_another_function(test_data) is not None
```
알다시피 Pytest와 UnitTest는 테스트 설정을 처리하는 서로 다른 방법을 갖고 있다.  
이는 Pytest와 UnitTest의 주요 차이점 중 일부이다.  

<br/>

Pytest가 사용하기 쉽고 읽기 쉬우므로 일반적으로는 Pytest를 선호한다. 그러나 UnitTest를 사용하는 것이편하면 Pytest를 굳이 사용하지 않아도된다. 


## 프로덕션을 위한 코드 준비

프로덕션으로 진행하기 전에 제공된 코드의 품질이 우수하고 예상대로 작동하는지 확인하는 것이 중요하다.  
모든 팀 또는 회사는 변경 사항이나 새 코드를 프로덕션에 배포하기 전에 수행하는 단계가 다르다.   
현재 배포 파이프라인에 몇 가지 사항을 도입해 프로덕션에서 오류를 줄이고 더 좋은 성능으로 개선할 수 있다.  

## 파이썬의 단위 테스트와 통합 테스트 실행
단위 테스트 수행 는 코드의 특정 단위를 확인하고 코드 단위가 작동하는지 확인하는데 도움이 된다.  
통합 테스트는 코드의 한 부분이 오류 없이 코드의 다른 부분과 작동하는지 테스트하는 것이 주요하다.  
통합 테스트로 코드가 전체적으로 작동하는지 확인할 수 있다.    

## 요약

모든 프로덕션 코드는 코드를 디버깅하고 좀 더 모니터링하는 데 도움이 되는 도구가 중요함.  
파이썬에는 코드를 프로덕션에 배포하기 전에 코드를 좀 더 다듬을 수 있는 많은 도구가 있다. 이러한 도구는 수백만 명의 사용자가 애플리케이션을 사용할 때 제 상태를 유지하는 데 유용할 뿐만 아니라 장기간 사용할 수 있도록 코드를 유지 관리하는 데 도움이 된다.  
프로덕션에서 애플리케이션을 배포할 때 올바른 프로세스를 유지하는 것은 애플리케이션의 품질을 높이기 위해 새로운 기능을 구축하는 것만큼 중요하게 여겨야 한다.  
