# 파이썬 코드의 디버깅과 테스트

## 디버깅
디버깅은 개발자에게 가장 중요한 기술 중 하나다. 디버깅은 개발 프로세스를 모두 마친 후에 수행돼서는 안 된다. 

### 디버깅 도구

### pdb
pdb는 파이썬 코드를 디버깅하는데 가장 유용한 command line 도구 중 하나다.  
pdb는 스택 정보와 매개변수 정보를 제공하고 pdb 디버거 내의 코드 명령으로 이동한다.  
파이썬 코드에서 디버거를 설정하기 위해 다음과 같이 작성할 수 있다.  

```python
import pdb
pdb.set_trace()
```
pdb 디버거가 사용 가능한 라인에 제어가 도달하면 pdb 명령줄 옵션을 사용해 코드를 디버깅 할 수 있다.  pdb는 다음 명령을 제공한다.  

- h : 도움말 명령
- w : 스택 트레이스(stack trace) 출력
- d : 현재 프레임 카운트를 아래로 이동
- u : 현재 프레임 카운트를 위로 이동 
- s : 현재 라인 실행
- n : 다음 라인까지 계속 실행
- unt [라인번호] : 라인 번호까지 계속 실행
- r : 현재 함수가 반환될 때까지 계속 실행

### ipdb
pdb와 유사하게 ipdb는 디버거 command line 도구다.  IPython의 ipdb를 사용할 수 있다는 추가 이점으로  
pdb와 동일한 기능을 제공한다. 다음과 같이 ipdb 디버거를 추가할 수 있다.  

```python
import ipdb
pdb.set_trace()
```

설치되면 ipdb에서 사용 가능한 모든 명령을 확인할 수 있다. 다음과 같이 대부분 pdb와 유사하다.  
- h : 도움말 명령
- w : 스택 트레이스(stack trace) 출력
- d : 현재 프레임 카운트를 아래로 이동
- u : 현재 프레임 카운트를 위로 이동 
- s : 현재 라인 실행
- n : 다음 라인까지 계속 실행
- unt [라인번호] : 라인 번호까지 계속 실행
- r : 현재 함수가 반환될 때까지 계속 실행

### pudb
pudb는 pdb와 ipdb보다 더 많은 기능을 가진 풍부한 디버깅 도구이며, 콘손을 기반으로 하는 시각적 디버거다. 
pdb나 ipdb와 같은 명령줄로 이동하는 대신에 코드를 작성할 때 코드를 디버깅할 수 있다. GUI 디버거처럼 보이지만, 콘손에서 실행되므로 GUI 디버거에 비해 가볍게 만들어졌다.  

```python
import pudb
pudb.set_trace()
```
pudb 단축키
- n : 다음 명령 실행
- s : 함수의 다음 단계
- c : 계속 실행
- b : 현재 라인 브레이크포인트 설정
- e : 넘겨진 예외의 트레이스백 표시
- q : 실행 중인 프로그램의 종료나 재시작을 위한 대화상자 오픈
- o : 원래 콘솔/표준 출력 화면 표시
- m : 다른 파일 모듈 오픈 
- L : 라인 이동
- ! : 화면 하단의 파이썬 명령줄 하위 창으로 이동
- ? : 전체 단축키 명령 리스트가 포함된 도움말 대화상자 표시
- <SHIFT + V> : 컨텍스트를 화면 오른쪽의 변수 하위 창으로 전환
- <SHIFT + B> : 컨텍스트를 화면 오른쪽의 브레이크 포인트 하위 창으로 전환
- <CTRL + X> : 코드 라인과 파이썬 명령중 간의 컨텍스트 토글

 예를 들어, pudb 화면에서 b를 누르면 c바로가기로 진행 후 실행이 중지되는 해당 라인에 브레이크 포인트가 설정 된다. 


## breakpoint
breakpoint는 파이썬 3.7에서 도입된 새로운 키워드이며 코드를 디버깅하는 기능을 제공한다.  

```python
x = 10
breakpoint()
y = 20
```
breakpoint() 함수가 호출될 메서드를 디버거에 제공하기 위해 PYTHONBREAKPOINT 환경 변수를 사용해 breakpoint를 구성할 수도 있다. 

## 프로덕션 코드 출력 대신 logging 모듈 사용

파이썬에는 로그를 기록하는 logging이라는 라이브러리가 있다.  
로깅은 코드의 흐름을 이해하는데 도움이 된다. 로깅이 사용 가능하자면, 스택트레이스르 제공해 오류가 발생한 위치를 알 수 있다.  


```python
# 로깅 사용 법
import logging
logging.getLogger(__name__).addHandler(logging.NUllHandler())
```

```python
import logging
from logging.config import dictConfig

loggigng_config = dict(version = 1,
                        formatter = {'f': {'format' : "%(asctime)s %(name) -12s %(levelname) -8s %(message)s"}},
                        handlers = {
                            'H':{'class' : 'logging.StreamHandler',
                            'formatter' : 'f',
                            'level' :logging.DEBUG,
                            }
                        },
                        root = {'handlers' :['h'], 'level' :logging.DEBUG}
)

dictConfig(logging_config)

logger = logging.getLogger()
logger.debug('This is debug logging')
```
로그의 전체 스택 트레이스를 캡쳐 하자.
```python
import logging
a = 90
b = 0
try : 
    c = a / b
except Exception as e:
    logging.error('Exception ', exc_info = True)
```

## 로깅 클래스와 함수
logging 모듈에는 나만의 로깅 클래스를 정의하고 특정 요구와 프로젝트의 로깅을 구성하는 데 사용할 수 있는 많은 클래스와 함수가 있다.    

<br/>  

- Logger: logging 모듈의 일부이며 logger 객체를 얻기 위해 애플리케이션에서 직접 호출된다. 다음과 같은 여러 메서드가 있다.
    - setLevel : 로깅 레벨을 설정. 로거가 생성되면 NOSET으로 설정
    - isEnableFor : 이 메서드는 loggigng.disable(level)에 의해 설정된 로깅 레벨을 확인
    - debug : 로거의 DEBUG 레벨로 메시지를 로깅
    - info : 로거의 INFO로 메시지를 로깅
    - waring : 로거의 WARING으로 메시지를 로깅
    - error : 로거의 ERROR 레벨로 메시지를 로깅
    - critical : 로거의 CRITICAL 레벨로 메시지를 로깅
    - log : 로거의 정수 레벨로 메시지 로깅
    - exception : 로거의 ERROR 레벨로 머시지를 로깅
    - addHandler : 로거의 특정 핸들러를 추가 
- Handler : Handler는 StreamHandler, FileHandler, SMTPHandler, HTTPHandler 등과 같은 기타 유용한 핸들러 클래스의 기본 클래스다. 이 서브클래스들은 `sys.stdout`이나 디스크 파일과 같은 것을 대상으로 로깅 출력을 전송함.
    - creatLock:기본 I/O 기능을 위한 액세스를 직렬화하는 데 사용할 수 있는 스레드 잠금을 초기화한다.
    - setLevel : 핸들러를 레벨로 설정한다.
    - flush : 로깅 출력이 플러시(flush) 되도록 한다.
    - clos : Handler의 서브클래스는 재정의된 close() 메서드에서 호출되도록 한다.
    - format: 출력 로깅의 형식을 정의한다.
    - emit: 실제로 특정 로깅 메시지를 로깅한다. 
- Formatter : 출력에 포함되는 속성을 나열하는 문자열 형식을 지정해 출력 형식을 지정한다. 
    - format: 문자열을 형식화한다.
    - formatTiem : 시간을 형식화한다. time.strftime()과 함께 사용해 레코드 생성 시간을 형식화한다. 
    - formatException : 특정 예외 정보를 형식화한다.
    - formatStack : 문자열의 스택 정보를 형식화한다.


```python
import logging
import logging.config

logging.config.fileConfig(fname='logging.conf', disable_existimg_loggers = False)

# 파일의 지정된 로거를 얻는다.
logger = logging.getLogger(__name__)

logger.debug('Debug logging message')
```

```YAML
#YAML 로깅 파일
version: 1
formatters:
  simple:
    format: '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
handlers:
  console:
    class: logging.StreamHandler
    level: DEBUG
    formatter: simple
    stream: ext://sys.stdout
loggers:
  sampleLogger:
    level: DEBUG
    handlers: [console]
    propagate: no
root:
  level: DEBUG
  handlers: [console]
```
```python
import logging
import logging.config
import yaml

with open('logging.yaml', 'r') as f:
    config = yaml.safe_load(f.read())
    logging.config.dictConfig(config)

logger = logging.getLogger(__name__)

logger.debug('Debug logging message')
```

## 병목 현상 식별을 위한 메트릭 라이브러리 사용
메트릭은 코드 특정 부분의 오류 개수나 서드 파티 API의 응답 시간처럼 코드에서 다양한 데이터 포인트를 수집한다.  
메트릭은 웹 애플리케이션에서 현재 로그인한 사용자 수와 같은 특정 데이터 요소를 수집하도록 정의될 수 있다.  

<br/>  

메트릭은 일반적으로 시스템 오버타임을 모니터링하기 위해 요청당, 초당, 분당 한번씩이나 정기적 간격으로 수집된다.  
메트릭은 다양한 종류가 있으며 `성능 메트릭(performance metric)` 이나 `리소스 메트릭(resource metric)` 으로 분류할 수 있다.  

- 성능 메트릭
    - Throughput : 시스템이 단위 시간당 수행하는 작업량
    - Error : 단위 시간당 오류 결과의 수나 요류의 비율
    - Performance : 작업 단위를 완료하는 데 필요한 시간
- 리소스 메트릭
    - Utilization : 리소스가 사용 중인 시간의 백분율
    - Availability : 리소스가 요청에 응답한 시간

메트릭을 사용하기 전에 애플리케이션을 추적하는 데 사용할 데이터 포인트의 종류를 고려하자.  
메트릭을 사용하면 애플리케이션에 대한 확신이 높아지고 애플리케이션 성능을 측정할 수 있다.  
