# 파이써닉 코드 작성

## 네이밍
파이썬 코드를 작성하는 동안 따라야 하는 명명 규칙 (필수는 아니지만 **권장**)

### 변수와 함수
- 소문자로 함수와 변수의 이름을 밑줄로 구분된 단어로 지정.
```python
names = 'Python' # 변수이름
job_title = 'Software Engineer' # 밑줄로 구분한 변수
popilated_countries_list  = [] #밑줄로 구분한 변수 
```

- 논맹글링 메서드 이름을 사용하는 것과 한 개의 밑줄(_) 이나 두 개의 밑줄(__)을 사용하는 것도 고려해야함
```python
_books = {} # 프라비잇으로 정의한 변수 이름
__dict = [] # 파이썬 내장 lib로 네임 맹글링(name mangling) 방지
```

```python
# 한 개의 밑줄로 구성한 함수 이름
def get_data():
    ---
    ---

def calculate_tax_data():
    ---
    ---
```
```python
# 프라이빗 메서드와 논맹글링을 나타내는 함수 이름
# 한개의 밑줄이 있는 프라이빗 메서드
def _get_data():
    ---
    ---

# 여러 내장 함수와 네임 맹글링을 방지하는 두 개의 밑줄
def __path():
    ---
    ---

```
- 네이밍 규칙을 따르는 것뿐만 아니라 함수나 변수에 모호한 이름을 사용하는 대신 특정 이름을 사용하는 것도 중요하다   
```python
#사용자 ID가 제공되는 경우 user 객체를 반환 하는 함수

# 잘못된 방법
def get_user_info(id):
    db = get_db_connection()
    user = execute_query_for_user(id)
    return user

# 올바른 방법
def get_user_by(user_id):
    db = get_db_connection()
    user = execute_query_for_user(id)
    return user
```
첫번째 함수는 매개변수 id가 무엇이든 의미할 수 있기 때문에 모호함. id는 사용자 테이블 인덱스 id나 사용자 지불 id, 또는 다른 id 일수도 있음.   
이러한 매개변수는 개발자들에게 혼동을 줄 여지가 있다.   

그래서 두번째 함수를 보면 함수 이름과 매개변수 이름을 수정해, 두번째 함수를 읽으면 함수의 목적과 예상 값을 바로 알 수 있다. 

### 클래스
- 클래스의 이름은 대부분의 다른 언어와 마찬가지로 `camel case`여야 한다.
```python
# 클래스 이름

class UserInformation:
    def get_user_by(user_id):
        db = get_db_connection()
        user = execute_query_for_user(id)
        return user
```

### 상수
- 상수 이름은 대문자로 정의 한다
```python
TOTAL = 56
TIMEOUT = 6
MAX_OVERFLOW = 7
```

### 함수 및 메서드 인자
- 함수 및 메서드 인자는 변수 및 메서드 이름과 동일한 규칙을 따라야함.
- 클래스 매서드는 키워드 매개변수로 self를 전달하지 않는 함수와 비교해 첫 번째 키워드 인자로 self를 가짐.

```python
def calculate_tax(amount, yearly_tax):
    ---

class Player:
    def get_total_score(self, player_name):
        ---
```

### 코드 표현과 구문
- 코드를 작성하다보면 라인 수를 줄이기 위해 무리하는 경우가 있다. 

```python
# 중첩 딕셔너리 정렬
users = [
    {"first_name": "Helen", "age": 39},
    {"first_name": "Buck", "age": 10},
    {"name": "anni", "age": 9}
    ]


users = sorted(users, key = lambda user : user['first_name].lower())

```

해당 코드를 살펴보면 한 라인에서 람다를 사용해 중첩 딕셔너리를 first_name로 정렬하고 있으므로 반복문 대신 딕셔너리를 정렬 하였다.  
그러나 람다 구문은 한 번에 이해하기 쉬운 개념이 아니므로 다른 개발자들이 바로 이해하기에 어려울 수 있다.  
람다보다는 함수를 사용해 코드를 읽기 쉽게 만들자. 함수는 예상치 못한 예시들을 확인할 것이고, 훨씬 작성하기 간편하다.

```python
users = [
    {"first_name": "Helen", "age": 39},
    {"first_name": "Buck", "age": 10},
    {"name": "anni", "age": 9}
    ]


def get_user_name(users):
    # 사용자 이름을 소문자로 변환
    return users["first_name"].lower()

def get_sorted_dictionary(users):
    """중첩 딕셔너리 정렬"""
    if not isinstance(users, dict):
        raise ValueError("Not a correct dictionary")
    if not len(users):
        raise ValueError("Empty dictionary")

    users_by_name = sorted(users, key=get_user_name)
    return users_by_name
```
함수를 활용한 코드는 예외 상황에 대해서도 유연하게 대처 할 수 있고, 람다를 사용한 코드보다 훨씬 읽기 쉽다. 한 줄 코드가 무작정 나쁘다는 아니지만 한번에 이해가 안된다면 그렇게 사용하지 않는 것이 맞다.  

## 코드 작성을 위한 파이써닉 방법의 수용

### 인플레이스 문자열 결합 대신 조인 사용

a = a + b와 같은 인플레이스 결합 대신 join()을 활용하자. `''.join()` 메서드는 더 빠른 시간을 보장한다.  
그 이유는 join을 사용하면 결합된 문자열에 메모리를 한 번만 할당하지만, 문자열을 연결하면 파이썬 문자열이 불변이므로 파이썬은 각 결합에 대해 새로운 메모리를 할당해야 한다.  

```python
first_name = 'Json'
last_name = "smart"

# 잘못된 방법
full_name = first_name + ' ' + last_name

# 빠른 속도와, 가독성 향상
" ".join([first_name,last_name])

```

### None와 비교가 필요한 경우 is와 is not 사용
None와 비교하기 위해 한상 is나 is not을 사용한다. 

```python
# 추천하지 않는 방법:

val = {}
if val:

#추천 하는 방법
if val is not None
```
- not ... 대신 not 사용
```python
# 추천하지 않는 방법
if not val is None:

# 추천하는 방법
if val is not None:
```

### 식별자 바인딩 시 람다 대신 함수 사용
- 특정 식별자에 람다 표현식을 할당할 때는 함수 사용을 고려한다. 

```python
# 추천하지 않는 방법
square = lambda x : xx* x

# 추천 하는 방법
def square(val):
    return val * val
```

### return 구문의 일관성 유지
- 함수가 값을 반환할 것으로 예상되면, 해당 함수의 모드 실행 경로에서 값을 반환하는지 확인하자.
```python
# 추천 하지 않는 방법
def calculate_interset(principle, time, rate):
    if principle > 0:
        return (principle * time * rate) / 100

def calculate_interset(principle, time, rate):
    if principle < 0:
        return 
    return (principle * time * rate) / 100


# 추천 하는 방법
def calculate_interset(principle, time, rate):
    if principle > 0:
        return (principle * time * rate) / 100
    else : 
        return None

def calculate_interset(principle, time, rate):
    if principle < 0:
        return None
    (principle * time * rate) / 100
```

### ''.statrwith()와 ''.endswith() 사용
접두사나 접미사를 확인해야 할 때 문자열을 자르는 대신 `''.startwith()`와 `''.endswith()`를 사용하는 것이 좋다.  
문자열 slice는 큰 문자열을 자르거나 연산시 효율이 더 좋지만, 단순히 접두사나 접미사를 확인하는 간단한 작업은 startwith, endswith를 사용하자. (코드를 읽기 쉽고 명확하게 만들자)
```python
# 추천하지 않는 방법
data = 'Hello, how are you doing?'
if data[:5] == 'Hello':

# 추천하는 방법
data = 'Hello, how are you doing?'
if data.startwith('Hello'):
```

### 두 객체 타입을 비교할 때는 type() 대신 isinstance() 메서드 사용

```python
# 추천하지 않는 방법
user_args = {"Larry" : 35, 'Jon' : 89}
if type(user_args) == dict

# 추천하는 방법
user_args = {"Larry" : 35, 'Jon' : 89}
if isinstance(user_args, dict)
```

### boolen 값을 비교하는 파이써닉 방법
```python
# 추천하지 않는 방법
if is_empty == False:
if is_empty is False

# 추천하는 방법

if is_empty :
```

### 린팅 도구를 사용한 파이썬 코드 개선
`코드 린터`는 코드를 일관되게 형식화하는 중요한 도구 이다. 프로젝트 전반에서는 일관된 코드 형식을 유지하는 것이 중요하다. 

린팅 도구는 기본적으로 아래 문제를 해결한다
- 구문 오류
- 미사용 변수 또는 정확한 인자를 함수에 전달하는 구조
- PEP8 가이드라인 위반 사항 지적

추천하는 린팅 도구는 `Flake8`과 `Pyline`이다.

린팅 도구 주요 기능
- PEP8 규칙 준수
- import 순서
- 네이밍
- 순환 import 
- 코드 복잡도
- 맞춤법
- 독스트링 스타일 검사