# 파이써닉 코드 작성

## 네이밍
파이썬 코드를 작성하는 동안 따라야 하는 명명 규칙 (필수는 아니지만 **권장**)

### 변수와 함수
- 함수와 변수의 이름은 소문자로, 또한 밑줄로 구분된 단어로 지정.

```python
names = 'Python' # 변수이름
job_title = 'Software Engineer' # 밑줄로 구분한 변수
popilated_countries_list  = [] #밑줄로 구분한 변수 
```

- 논맹글링 메서드 이름을 사용하는 것과 한 개의 밑줄(_) 이나 두 개의 밑줄(__)을 사용하는 것도 고려해야함
```python
_books = {} # 프라비잇으로 정의한 변수 이름
__dict = [] # 파이썬 내장 lib로 네임 맹글링(name mangling) 방지
```

```python
# 한 개의 밑줄로 구성한 함수 이름
def get_data():
    ---
    ---

def calculate_tax_data():
    ---
    ---
```
```python
# 프라이빗 메서드와 논맹글링을 나타내는 함수 이름
# 한개의 밑줄이 있는 프라이빗 메서드
def _get_data():
    ---
    ---

# 여러 내장 함수와 네임 맹글링을 방지하는 두 개의 밑줄
def __path():
    ---
    ---

```
- 네이밍 규칙을 따르는 것뿐만 아니라 함수나 변수에 모호한 이름을 사용하는 대신 특정 이름을 사용하는 것도 중요하다   
```python
#사용자 ID가 제공되는 경우 user 객체를 반환 하는 함수

# 잘못된 방법
def get_user_info(id):
    db = get_db_connection()
    user = execute_query_for_user(id)
    return user

# 올바른 방법
def get_user_by(user_id):
    db = get_db_connection()
    user = execute_query_for_user(id)
    return user
```
첫번째 함수는 매개변수 id가 무엇이든 의미할 수 있기 때문에 모호함. id는 사용자 테이블 인덱스 id나 사용자 지불 id, 또는 다른 id 일수도 있음.   
이러한 매개변수는 개발자들에게 혼동을 줄 여지가 있다.   

그래서 두번째 함수를 보면 함수 이름과 매개변수 이름을 수정해, 두번째 함수를 읽으면 함수의 목적과 예상 값을 바로 알 수 있다. 

### 클래스
- 클래스의 이름은 대부분의 다른 언어와 마찬가지로 `camel case`여야 한다.
```python
# 클래스 이름

class UserInformation:
    def get_user_by(user_id):
        db = get_db_connection()
        user = execute_query_for_user(id)
        return user
```

### 상수
- 상수 이름은 대문자로 정의 한다
```python
TOTAL = 56
TIMEOUT = 6
MAX_OVERFLOW = 7
```

### 함수 및 메서드 인자
- 함수 및 메서드 인자는 변수 및 메서드 이름과 동일한 규칙을 따라야함.
- 클래스 매서드는 키워드 매개변수로 self를 전달하지 않는 함수와 비교해 첫 번째 키워드 인자로 self를 가짐.

```python
def calculate_tax(amount, yearly_tax):
    ---

class Player:
    def get_total_score(self, player_name):
        ---
```

### 코드 표현과 구문
- 코드를 작성하다보면 라인 수를 줄이기 위해 무리하는 경우가 있다. 

```python
# 중첩 딕셔너리 정렬
users = [
    {"first_name": "Helen", "age": 39},
    {"first_name": "Buck", "age": 10},
    {"name": "anni", "age": 9}
    ]


users = sorted(users, key = lambda user : user['first_name].lower())

```

해당 코드를 살펴보면 한 라인에서 람다를 사용해 중첩 딕셔너리를 first_name로 정렬하고 있으므로 반복문 대신 딕셔너리를 정렬 하였다.  
그러나 람다 구문은 한 번에 이해하기 쉬운 개념이 아니므로 다른 개발자들이 바로 이해하기에 어려울 수 있다.  
람다보다는 함수를 사용해 코드를 읽기 쉽게 만들자. 함수는 예상치 못한 예시들을 확인할 것이고, 훨씬 작성하기 간편하다.

```python
users = [
    {"first_name": "Helen", "age": 39},
    {"first_name": "Buck", "age": 10},
    {"name": "anni", "age": 9}
    ]


def get_user_name(users):
    # 사용자 이름을 소문자로 변환
    return users["first_name"].lower()

def get_sorted_dictionary(users):
    """중첩 딕셔너리 정렬"""
    if not isinstance(users, dict):
        raise ValueError("Not a correct dictionary")
    if not len(users):
        raise ValueError("Empty dictionary")

    users_by_name = sorted(users, key=get_user_name)
    return users_by_name
```
함수를 활용한 코드는 예외 상황에 대해서도 유연하게 대처 할 수 있고, 람다를 사용한 코드보다 훨씬 읽기 쉽다. 한 줄 코드가 무작정 나쁘다는 아니지만 한번에 이해가 안된다면 그렇게 사용하지 않는 것이 맞다.  

## 코드 작성을 위한 파이써닉 방법의 수용

### 인플레이스 문자열 결합 대신 조인 사용

a = a + b와 같은 인플레이스 결합 대신 join()을 활용하자. `''.join()` 메서드는 더 빠른 시간을 보장한다.  
그 이유는 join을 사용하면 결합된 문자열에 메모리를 한 번만 할당하지만, 문자열을 연결하면 파이썬 문자열이 불변이므로 파이썬은 각 결합에 대해 새로운 메모리를 할당해야 한다.  

```python
first_name = 'Json'
last_name = "smart"

# 잘못된 방법
full_name = first_name + ' ' + last_name

# 빠른 속도와, 가독성 향상
" ".join([first_name,last_name])

```

### None와 비교가 필요한 경우 is와 is not 사용
None와 비교하기 위해 한상 is나 is not을 사용한다. 

```python
# 추천하지 않는 방법:

val = {}
if val:

#추천 하는 방법
if val is not None
```
- not ... 대신 not 사용
```python
# 추천하지 않는 방법
if not val is None:

# 추천하는 방법
if val is not None:
```

### 식별자 바인딩 시 람다 대신 함수 사용
- 특정 식별자에 람다 표현식을 할당할 때는 함수 사용을 고려한다. 

```python
# 추천하지 않는 방법
square = lambda x : xx* x

# 추천 하는 방법
def square(val):
    return val * val
```

### return 구문의 일관성 유지
- 함수가 값을 반환할 것으로 예상되면, 해당 함수의 모든 실행 경로에서 값을 반환하는지 확인하자.
```python
# 추천 하지 않는 방법
def calculate_interset(principle, time, rate):
    if principle > 0:
        return (principle * time * rate) / 100

def calculate_interset(principle, time, rate):
    if principle < 0:
        return 
    return (principle * time * rate) / 100


# 추천 하는 방법
def calculate_interset(principle, time, rate):
    if principle > 0:
        return (principle * time * rate) / 100
    else : 
        return None

def calculate_interset(principle, time, rate):
    if principle < 0:
        return None
    return (principle * time * rate) / 100
```

### ''.statrwith()와 ''.endswith() 사용
접두사나 접미사를 확인해야 할 때 문자열을 자르는 대신 `''.startwith()`와 `''.endswith()`를 사용하는 것이 좋다.  
문자열 slice는 큰 문자열을 자르거나 연산시 효율이 더 좋지만, 단순히 접두사나 접미사를 확인하는 간단한 작업은 startwith, endswith를 사용하자. (코드를 읽기 쉽고 명확하게 만들자)
```python
# 추천하지 않는 방법
data = 'Hello, how are you doing?'
if data[:5] == 'Hello':

# 추천하는 방법
data = 'Hello, how are you doing?'
if data.startwith('Hello'):
```

### 두 객체 타입을 비교할 때는 type() 대신 isinstance() 메서드 사용

```python
# 추천하지 않는 방법
user_args = {"Larry" : 35, 'Jon' : 89}
if type(user_args) == dict

# 추천하는 방법
user_args = {"Larry" : 35, 'Jon' : 89}
if isinstance(user_args, dict)
```

### boolen 값을 비교하는 파이써닉 방법
```python
# 추천하지 않는 방법
if is_empty == False:
if is_empty is False

# 추천하는 방법

if is_empty :
```

### 린팅 도구를 사용한 파이썬 코드 개선
`코드 린터`는 코드를 일관되게 형식화하는 중요한 도구 이다. 프로젝트 전반에서는 일관된 코드 형식을 유지하는 것이 중요하다. 

린팅 도구는 기본적으로 아래 문제를 해결한다
- 구문 오류
- 미사용 변수 또는 정확한 인자를 함수에 전달하는 구조
- PEP8 가이드라인 위반 사항 지적

추천하는 린팅 도구는 `Flake8`과 `Pyline`이다.

린팅 도구 주요 기능
- PEP8 규칙 준수
- import 순서
- 네이밍
- 순환 import 
- 코드 복잡도
- 맞춤법
- 독스트링 스타일 검사

## 독스트링 사용
독스트링은 파이썬에서 코드를 문서화하는 방법이다. 독스트링은 일반적으로 메서드, 클래스, 모듈의 시작 부분에 작성 된다.  
또한 해당 객체의 `__doc__` 특수 속성이 된다.  파이썬 공식 언어는 독스트링을 작성하기 위해 """삼중 큰따옴표"""를 사용하는 것을 추천한다.  

```python
# 독스트링을 사용한 함수
def get_prime_number():
    """1에서 100사이의 소수 목록을 가져온다."""
```
독스트링 작성 규칙
- 문자열이 한 라인에 있어도 삼중 따옴표 사용.
- 삼중 따옴표의 문자열 전후에 빈 라인이 없어야 함.
- 마침표(.)를 사용해 독스트링에서 구문을 종료.

### 멀티라인 독스트링
- 첫 번째 라인은 함수나 클래스에 대한 간략한 설명
- 라인의 끝부분에 마침표
- 간단한 설명과 독스트링의 요약 사이에 한 라인의 간격이 있음

```python
def call_weather_api(url, location):
"""특정 위치의 날씨를 얻는다.  

날씨 API와 위치를 사용해 날씨를 확인하고자 날씨 API를 호출한다.
도시 이름만 제공할 수 있도록 하고, 국가 및 카운티 이름은 
허용되지 않을 것이며 도시 이름을 찾이 못하면 예외를 발생시킬 것이다.

:param ulr: 날씨를 얻기 위한 api URL
:type url: str
:param location: 날씨를 확인하려는 도시 위치
:type location: str
:return : 주어진 위치의 날씨 정보 반환
:rtype: str

```

### typing과 멀티라인 독스트링
- 파이썬 코드에서 타입을 사용하는 경우 매개변수 정보를 작성할 필요가 없다.

```python
def call_weather_api(url: str, location: str) -> str:
"""특정 위치의 날씨를 얻는다.  

날씨 API와 위치를 사용해 날씨를 확인하고자 날씨 API를 호출한다.
도시 이름만 제공할 수 있도록 하고, 국가 및 카운티 이름은 
허용되지 않을 것이며 도시 이름을 찾이 못하면 예외를 발생시킬 것이다.
```


### 모듈 레벨 독스트링
모듈의 사용법을 간략히 설명하기 위해 파일의 맨 위에 모듈 레벨 독스트링을 위치시킨다. 
모듈 독스트링은 import 전에 있어야 하고, 모듈의 모든 메서드/클래스를 포함해 모듈의 목표를 살펴봐야 함.

```python
"""
이 모듈은 모든 네트워크 관련 요청을 포함한다. 이 모듈은 네트워크를 호출하는 동안 모든 예외를 검사하고 
알 수 없는 예외에 대한 예외를 발생시킨다. 이 모듈을 사용할 때 클라이언트 코드에서 이러한 예외를 처리한다.
네트워크 호출을 위한 NetworkError 예외.
네트워크를 찾을 수 없는 경웅 NetworkNotFound 예외
"""

import urlib3
import json
...

```
모듈을 위한 독스트링 작성 요령
- 모듈의 목적에 대한 간단한 설명 작성
- 예제 처럼 모듈에 대해 알아야 할 정보를 확인하기 위한 예외 정보를 추가할 수 있지만, 너무 자세하게 언급 금지
- 모든 함수 또는 클래스 연산의 세부 사항을 살펴보지 않고 모듈의 설명 정보를 제공하는 방법으로 모듈 독스트링 고려.

### 클래스 독스트링
클래스 독스트링은 주로 클래스의 사용과 전체적인 목표를 간략하게 설명하는데 사용됨.
```python
class Student:
    """이 클래스는 학생이 수행한 작업을 처리한다."""

    def __init__(self):
        pass
```

### 멀티라인 클래스 독스트링
```python
class Student:
    """Student 클래스 정보 

    이 클래스는 학생이 수행한 작업을 처리한다.
    이 클래스는 학생의 성명, 나이, 전화번호와 기타 정보를 제공한다.

    사용법:
    import student

    student = student.Student()
    student.get_name()
    >> 678988
    """

    def __init__(self)
    pass
```


### 함수 독스트링
함수 독스트링은 함수 뒤 또는 함수의 맨 위에 작성할 수 있다. 함수 독스트링은 주로 함수의 연산을 설명함.

```python
def is_prime_number(number):
    """소수를 확인함.

    주어진 수의 제곱근보다 작은 모든 수를 확인해 주어진 수가 소수인지 아닌지 확인.

    :param number: 소수인지 검사히기 위해 주어진 숫자
    :type number: int
    :return: 만약 소수이면 True, 그렇지 않으면 False
    :rtype: boolen
    """
```

<br/>  
<br/>  
---
독스트링은 파이썬의 훌륭한 기능이며 코드를 문서화하기가 쉽다. 가능한 한 빨리 코드에서 독스트링을 사용하기 시작하면,  
프로젝트가 수천 라인 수준의 규모로 커졌을 때 많은 시간을 투자할 필요가 없을 것이다.
---

# 파이써닉 제어 구조 작성
---
제어 구조는 모든 프로그래밍 언어의 기본 부분이며, 파이썬에서도 마찬가지이다.  
파이썬 에서 제어 구조에 대한 좋은 사례에대해 알아보자

## 리스트 컴프리헨션 사용
리스트 컴프리헨션은 파이썬 for 루프와 비슷한 방식으로 기존의 문제를 해결하는 코드를 작성하는 방법  if 조건이 있거나 없는 리스트 내에서 수행 가능함.  
파이썬에서는 다른 리스트로부터 리스트를 파생하는 여러 가지 방법이 있는데(filter, map 활용), 리스트 컴프리헨션을 사용하면 코드의 가독성이 더 좋다.  



```python
# numbers 리스트값들의 제곱 값 추출
numbers =  [10, 45, 34, 89, 34, 23, 6]
#map
square_numbers = map(lambda num: num **2, numbers)
#리스트 컴프리헨션
square_numbers = [num**2 for num in numbers]
```


```python
# 모든 참 값에 필터(filter)를 사용하는 예제
data = [1, "A", 0, False, True]

#map
filtered_data = filter(None, data)

#리스트 컴프리헨션
filtered_data = [item for item in data if item]
filtered_data
```




    [1, 'A', True]



for 반복문에 복잡한 조건이나 복잡한 계산이 없는 경우 리스트 컴프리헨션을 사용하자. 
그러나 루프에서 많은 작업을 하는 경우에는 가독성을 위해 for 문을 사용 하는 것이 좋다.  



```python
list_char = ["a",'b','c','g','j']
vowel = ['a','e','i','o','u']
only_vowel = []
for item in list_char:
    if item in vowel:
        only_vowel.append(item)
```


```python
[item for item in list_char if item in only_vowel]
```

보다시피, 이 예제는 루프를 사용할 때보다 리스트 컴프리헨션을 사용할 때 코드 라인이 훨씬 더 읽기 쉽다. 또한 루프는 매번 리스트에 item을 추가해야 하므로 성능 저하가 발생할 수있는데, 리스트 컴프리헨션은 그렇지 않음.

### 복잡한 리스트 컴프리헨션 생성 금지
리스트 컴프리헨션이 너무 복잡하면 코드 가독성도 저하시키고 오류를 쉽게 유발할 수 있음.  
**리스트 컴프리헨션은 하나의 조건을 가진 최대 두 개의 루프에 적합함.**



```python
# 행렬을 변경하는 예제
matrix_1 = [[1,2,3],
         [4,5,6],
         [7,8,9]]

matrix_2 = [[1,4,7],
            [2,5,8],
            [3,6,9]]

# matrix_1 -> matrix_2

[[matrix_1[row][col]
 for row in range(0, 3)]
 for col in range(0,3)]
```




    [[1, 4, 7], [2, 5, 8], [3, 6, 9]]



위 예제에서는 코드를 쉽게 이해할 수 있기 때문에 리스트 컴프리헨션을 사용하는 것이 좋다.  


```python
# 여러 개의 if 조건문이 존재

ages = [1, 34, 5, 7, 3, 57, 356]
old = [age for age in ages if age > 10 and age < 100 and age is not None]

# 해당 경우는 리스트 컴프리헨션보다 for 반복문을 사용하는 것이 바람직
for age in ages:
    if age > 10 and age < 100:
        old.append(age)
print(old)
```

    [34, 57, 34, 57]
    

리스트 컴프리헨션을 사용하면 명확하게 코드의 품질이 올라간다. 그러나 리스트 컴프리헨션의 과도한 사용은 코드의 가독성을 저하시킬 수 있다. 따라서 하나 이상의 조건이나 루프일 수 있는 복합 구문을 작성할 때는 리스트 컴프리헨션의 사용을 자제한다. 


## 람다를 사용해야 하나 ?

함수를 대체할 방법으로 표현식에 도움이 되는 `람다식` 사용을 고려 할 수 있음.
```python
data = [[7],[2],[5],[1],[3]]

def min_val(data):

    """데이터 리스트에서 최솟값을 찾는다."""
    return min(data, key=lambda x :len(x))
```
위 예제에서는 리스트에서 최솟값을 찾기 위해 람다를 일회용 함수로 사용하고 있음.   
하지만 람다를 위와 같이 사용하는 것은 추천하지 않는다.  

```python
data = [[7],[2],[5],[1],[3]]

def min_val(data):

    """데이터 리스트에서 최솟값을 찾는다."""
    return min(data, key=def f(x) : return 2*x)
```
위 예시와 같이 람다표현시글 직접 이름에 바인딩하는 대입문 대신 항상 def 구문을 사용하자.

## 제너레이터와 리스트 컴프리헨션을 사용해야 하는 경우

제너레이터와 리스트 컴프리헨션 간의 주요 차이점은 **리스트 컴프리헨션은 데이터를 메모리에 보관하지만 제너레이터는 보관하지 못한다는 것** 이다.

- 리스트 컴프리헨션을 사용하는 경우
    - 리스트를 여러 번 반복해야 하는 경우
    - 제너레이터에서 사용할 수 없는 데이터를 메서드로 나열해야 하는 경우
    - 반복할 대용량 데이터가 없고 데이터를 메모리에 보관하는 것은 문제가 되지 않는 다고 생각되는 경우


```python
#리스트 컴프리헨션 사용
def read_file(file_name):
    """Read the file line by line."""
    fread = open(file_name, "r")
    data = [line for line in fread if line.startswith(">>")]
    return data

```

파일이 너무 커서 리스트에 많은 라인이 있으면, 메모리에 영향을 주고 코드를 느리게 만들 수 있다. 따라서 위 예제에서는 이터레이터의 사용을 고려하는 것이 좋다.

```python
# 이터레이터 사용
def read_file(file_name):
    """Read the file line by line."""
    with open(file_name) as fread:
        for line in fread:
            yield line


for line in read_file("logfile.txt"):
    print(line.startswith(">>")
```

## 예외 발생

예외는 코드에서 오류를 보고하는 데 도움이 된다. 파이썬에서는 예외가 내장 모듈에 의해 처리된다.  
예외를 잘 이해하는 것은 중요하다. 예외를 언제 어디에서 사용하는지 이해하면 코드에서 오류가 발생하는 상황을 감소시킬 수 있다.  

예외는 많은 노력 없이 코드에서 오류를 노출시킬 수 있으므로 코드에 예외를 추가하자!  

## 자주 발생하는 예외

필자는 일반적으로 현재 코드 블록에 대한 근본적인 가정이 거짓(false)으로 밝혀질 때마다 예외를 발생시키는 것을 선호함.  
파이썬에서는 코드에서 실패했을 때 예외가 발생되는 것을 선호한다. 계속적인 실패가 발생하면 예외를 발생시키길 원한다.  

```python
def division(dividedn, divisor):
    """산술적 나눗셈을 수행한다."""

    try :
        return dividend/divisor

    except ZeroDivisionError as zero:
        raise ZeroDivisionError("Please provided greater than 0 value")
```
위 예시 처럼 작성하게 되면 코드에 ZeroDivisionError가 있을 때마다 코드에 오류가 발생하고   
다른 방법으로 처리할 수 있도록 하는 데 호출 코드가 도움이 된다.

```python
result = division(10, 2)


def division(dividend, divisor):
    """나눗셈 수행 함수"""
    try : 
        return dividend/divisor
    except ZeroDivisionError as zero:
        return None
```
위와 같이 예외상황에 대해 None를 반환하는 경우, 코드 크기가 커지거나 요구 사항이 변경되면 향후 처리 하기가 어렵다.  
호출자가 함수 실행 중에 실패한 것을 쉽게 이해할 수 있도록 실패나 예외가 발생하는 경우 None를 반환하는 것을 피하는 것이 좋다.  

## 예외 처리에서 finally의 장점
finally 키워드는 특히 리소스를 다룰때, 예외를 처리하는 동안 유용하다. 예외가 발생했는지 여부에 관계없이 최종적으로  
파일이나 리소스가 닫혔는지 또는 해제됐는지 확인하는 데 사용할 수 있음.  
예외를 포착하지 못했거나 포착할 특정 예외가 없는 경우에도 마찬가지이다.


```python
def send_email(host, port, user, password, email, message):
    """특정 이메일 주소로 이메일을 보내는 함수"""
    try :
        server = smtlib.SMTP(host = host, port = port)
        server.ehlo()
        server.login(user, password)
    finally : server.quite()
```

위 예시에서 로그인 과정이나 send_email 작업 수행 중에 어떤 예외가 발생하는 경우,   
서버 연결의 리소르를 정리하는데 도움이 되는 finally를 사용해 예외를 처리한다.

```python
def write_file(file_name):
    """Read given file line by line""""
    myfile = open(file_name, "w")
    try:
        myfile.write("Python is awesome")           # Raise TypeError
    finally:
        myfile.close()             # TypeError가 전파되기 전에 실행
```

여기서는 finally 블록 내부에서 파일을  닫는 처리를 한다. 예외 여부와 상관없이 코드는 항상 실행돼 파일을 닫는다. 
finally를 사용하면 리소스를 현명하게 처리할 수 있을 뿐만 아니라 코드를 좀 더 명확하게 작성할 수 있음.  

## 나만의 예외 클래스 생성

API 또는 라이브러리를 생성하거나 프로젝트 또는 API와의 일관성을 유지하기 위해서, 나만의 예외 클래스를 생성하는 것을 추천  
코드를 디버깅하는 동안 엄청난 도움이 된다.  

다음 예시는 데이터베이스에서 사용자를 찾을 수 없을 때 예외를 발생시켜야 한다고 가정하자.  
예외 클래스 이름이 오류의 의도를 반영하는지 확인한다.  

```python
# 특정 예외 클래스 생성

class UserNotFoundException(EXcpetion):
    """사용자를 찾을 수 없는 경우 예외를 발생 시킴."""

    def __init__(self,message = None, errors = None):

        # 필요한 매개변수로 기본 클래스 생성자 호출
        super().__init__(message)

        # 새로운 사용자 정의 코드
        self.errors = errors
def get_user_info(user_obj):

    """DB에서 사용자 정보를 얻는다."""

    user = get_user_from_db(user_obj)
    if not user:
        raise UserNotFoundException(f"No user found of this id: {user_obj.id}")

get_user_info(user_obj)
>>> UserNotFoundException : No user found of this id :897867

```

직접 예외에 대한 경계를 정의하게되면 코드를 쉽게 진단할 수 있다.  

예외 클래스의 이름을 정의하며 예외 클래스에 대한 더 넓은 범위를 정의할 수도 있지만, 
아래 예제 처럼 클래스 명은 특정 사례를 처리한다는 것을 나타내야 한다.  

```python
class ValdationError(Exception):
    """유효성 검사가 실패할 때마다 예외를 발생시킨다."""

    def __init__(self, message =None, errors = None):

        # 필요한 매개변수로 기본 클래스 생성자 호출
        super().__init__(message)

        # 새로운 사용자 정의 코드
        self.errors = errors

```


위 예외는 UserNotFOundException과 비교해 훨씬 광범위한 범위를 가진다.  
그러나 경계는 여전히 유효성 컨텍스트에 의해 정의된다.  그러므로 예외 범위를 알아두고, 예외 클래스의 범위에서 오류가 발견되면 예외를 발생시킨다 !   

## 특정 예외 처리

예외를 포착하는 동안 except: 절을 사용하는 대신 특정 예외만 잡는 것을 추천함.  
`except:  혹은 except Exception은 각각의 모든 예외를 처리함.  `



```python
# 추천 하지 않는 방법
def get_enec_list(num_list):
    """주어진 리스트에서 짝수 리스트를 얻는다."""
    # NoneType 또는 TypeError 예외를 발생시킬 수 있다.
    return [item for item in num_list if item%2 ==0]

numbers = None
try : 
    get_even_list(numbers)
except : 
    print("Something is wrong")
```

    Something is wrong
    

위와 같은 코드는 명백한 코드 버그인 NoneType 또는 TypeError와 같은 예외를 숨기며, 정확한 에러를 파악하는데 어려움을 겪게 될 것임.  

그래서 위와 같이 작성하기 보다는 명백하게 어떤 에러가 발생하는지 잡는것을 추천 


```python
# 추천 하는 방법 
def get_even_list(num_list):
    """지정된 리스트에서 짝수 리스트를 얻는다."""
    #NoneType 또는 TypeError 예외를 발생시킬 수 있다.
    return [item for item in num_list if item%2==0]

numbers = None
try : 
    get_even_list(numbers)
except TypeError:
    print("Type error has been raised due to non sequential data type.")

```

    Type error has been raised due to non sequential data type.
    

위 예시 처럼 특정 예외를처리하면 문제를 디버깅하거나 진단하는 데 도움이 됨.  
호출자는 코드가 실패한 이유를 즉시 알게 되고, 특정 예외를 처리하는 코드를 추가하게 될 것이다.  

### 최소한의 try 코드 선호

코드에서 예외를 처리할 때마다 최소한의 try 문을 사용하도록 하자.  이렇게 하면 다른 개발자가 코드의 어느 부분에 오류가 발생할 여지가 있는지 명확히 알 수 있다.  
예외 처리를 위해 try/catch 블록이 없으면 이런 걱정은 할 필요가 없을 수 있다. 그러나 예외가 처리되지 않으면 애플리케이션이 실패할 수있다.  
따라서 좋은 예외 처리를 하면 코드 오류가 발생하지 않을 것 이다. 


```python
#추천하지 않는 방법
def write_to_file(file_name, message):
    """특정 메시지를 파일에 작성"""
    try :
        write_file = open(file_name,'W')
        write_file.write(message)
        write_file.close()
    except FileNotFoundError as exc:
        FileNotFoundException('Please provide correct file')
```

위 예시에서는 FileNotFound 에러 외에도 IOError에러 또한 발생 할 수 있다.  
그래서 해당 에러를 아래와 같이 try문에 포함 시켜 준다.  


```python
#추천하지 않는 방법
def write_to_file(file_name, message):
    """특정 메시지를 파일에 작성"""
    try :
        write_file = open(file_name,'W')
        write_file.write(message)
        write_file.close()
    except (FileNotFoundError, IOError) as exc:
        FileNotFoundException('Having issue while writing into file {exc}')
```

다른 라인에서 예외가 발생할 위험이 없더라도 다음과 같이 최소한의 try 문을 사용 하자.


```python
# 추천하지 않는 방법
try :
    data = get_data_from_db(obj)
    return data
except DBConnectionError:
    raise
```


```python
# 추천하는 방법

try :
    data = get_data_from_db(obj)
except DBConnectionError:
    raise
return data
```

코드가 더 명확해진다. get_data_from_db 메서드에 액세스 하는 동안만 (return 시에는 error 발생 x ) 예외가 발생할 것으로 생각 할 수 있다.
