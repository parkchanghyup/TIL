# 제너레이터와 이터레이터

파이썬에서 `제너레이터`와 `이터레이터`를 사용하면 데이터 문제를 더욱 쉽게 처리할 수 있으며, 좀 더 명확하고 성능이 좋은 코드를 작성하는 데 도움이 된다.  

## 이터레이터의 이해

이터레이터는 데이터 스트림에서 작동하는 객체이다.  
이터레이터 객체는 `__next__`라는 객체를 가지고 있으며, for 루프, 리스트 컴프리헨션등에서 데이터를 얻기 위한 무언가를 사용할 때 백그라운드에서 \_\_next__메서드가 호출 됩니다.  

```python
class MultiplayByTwo:
    def __init__(self, number):
        self.number = number
        self.count = 0
    
    def __next__(self):
        self.count += 1
        return self.number * self.count

mul = MultiplyByTwo(500)
print(next(mul))
print(next(mul))
print(next(mul))

>>>500
>>>1000
>>>1500
```

위 코드에는 호출 할 때마다 새 이터레이터를 반환하는 \_\_next__ 메서드를 가진 MultiplyByTwo라는 클래스가 있다.  
이터레이터는 \_\_next__ 내부의 카운터 변수를 사용해 시퀀스에 대한 레코드를 유지해야 한다. 그러나 for 루프에서 이 클래스를 사용하려고하면 다음과 같은 에러가 발생한다.  

```python
for num in MultiplyByTwo(500):
    print(num)
>>> 'MultiplyByTwo' object is not iterable.
```
 MultiplyByTwo는 이터레이터이며 iterable 하지 않다.  따라서 for 루프는 작동하지 않는다. 

 ### iterable vs 이터레이터
 이터러블 객체에는 \_\_iter__라는 메서드가 있으며, 이 메서드는 이터레이터를 반환한다.   
 \_\_iter__가 모든 객체에서 호출되면, 데이터를 가져오기 위해 객체를 반복하는데 사용할 수 있는 이터레이터를 반환한다.   
 파이썬에서 문자열, 리스트, 파일, 딕셔너리는 모두 이터러블의 예제다.

<br/>  

이터레이터에 대해 for 루프를 시도하면 루프가 이터레이터를 반환하기 때문에 잘 작동할 것이다.  
```python
class MultiplayByTwo:
    def __init__(self, number):
        self.number = number
        self.count = 0
    
    def __iter__(self):
        return self

    def __next__(self):
        self.count += 1
        return self.number * self.count

for num in MultiplyByTwo(500):
    print(num)
```
위의 이터레이터는 영구적으로 실행되는 이터레이터이다. 그렇다면 한정된 수의 이터레이터는 어떻게 만들 수 있을까 ? 

```python
class MultiplayByTwo:
    def __init__(self, number, limit):
        self.number = number
        self.limit = limit
        self.count = 0

    
    def __iter__(self):
        return self

    def __next__(self):
        self.count += 1
        value = self.number * self.counter

        if value > self.limit:
            raise StopIteration
        else:
            return value

for num in MultiplyByTwo(500,5000):
    print(num)
```
StopIteration을 발생시키면 MultiplyByTwo 객체가 한계치를 넘었다는 신호르 받고, 파이썬에서 자동으로 처리하는 예외르 발생시켜 루프를 종료시킨다.  

## 제너레이터란 ?
제너레이터란 많은 양의 데이터나 많은 수의 파일을 읽는데 유용하며, 일시중지했다가 재시작할 수 있다.    
또한 다른 데이터구조와 달리 한번에 하나씩 항목을 생성하기 때문에 메모리 효율적이다.  

```python
def multiple_generator(number, limit):
    counter = 1
    value = number * counter

    while value <= limit:
        yield value
        counter += 1
        value = number * counter

for num in multiple_generator(500,5000):
    print(num())
```

\_\_next__와 \_\_iter__을 정의할 필요가 없으므로 이터레이터 예제보다 훨씬 코드가 짧다.   
`yield`키워드는 return과 비슷하지만, 함수를 종료 하는 대신 다른 값을 요청할 때까지 실행을 일시 중지한다.  제너레이터는 이터레이터에 비해 훨씬 읽기 쉽고 성능이 뛰어나다.  

## 이터레이터를 사용하는 경우 ?  

이터레이터는 파일이나 데이터 스트림 형태로 많은 집합을 처리할 때 실제로 유용하다.  
이터레이터는 메모리에 모든 데이터를 로드하는 대신 한 번에 하나씩 데이터를 처리할 수 있는 유연성을 제공한다.  

이터레이터를 이용해 데이터베이스의 데이터를 읽어보자.  
전자상거래 회사가 온라인 상점을 통해 제품을 판매하고 사용자가 온라인 결제로 해당 제품을 구매하는 시나리오라면,  
사용자의 결제는 payment라는 테이블에 저장되며, 24시간이 지나면 자동 시스템이 Payment 테이블을 조회하고 지난  24시간 동안의 총수익을 계산한다.  

```python
def get_total_payment():
    payments = Payment.objects.all()
    sum_amount = 0

    if payments.exists():
        for payment in payments.iterator():
            sum_amount += payment
    return sum_amount
```
위 예제는 모든 데이터를 한 번에 로드하지 않고 데이터베이스에서 한 번에 한 행씩 데이터를 가져온 후 총합을 계산한다.  

## itertools 사용 

- combinations()
- ex) combinations(iterable, r)
```python
# r길이인 iterable 튜플 조합 반환
from itertools import combinations

print(list(combinations('12345',2)))
[('1', '2'), ('1', '3'), ('1', '4'), ('1', '5'), ('2', '3'), ('2', '4'), ('2', '5'), ('3', '4'), ('3', '5'), ('4', '5')]
```

- permutatinos()
- ex) permutatinos(iterable, r))
```python
# r길이의 모든 순열 반환
from itertools import permutations

print(list(permutations([1,2,3],2)))
[(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]
```

- product()
- ex) product(x,y) -> ((x,y) for x in A for y in B)
```python
from itertools import product

print(list(product([1,2,3], repeat = 2)))
[(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]
```

- count()
- ex. count(start = 0,step =1)

```python
#start로 시작해 균등한 간격으로 숫자를 반환하는 이터레이터.
import itertools

for num in itertools.count(1, 4):
    print(num, end = ' ')
    if num > 24 :
        break
>>> 1 5 9 13 17 21 25 
```

- groupby
- ex) groupby(iterable, key= None)
```python
from itertools import groupby

numbers ='112243332455'
result = []
for num, length in groupby(numbers):
    result.append((len(list(length)), int(num)))
    
print(result)
[(2, 1), (2, 2), (1, 4), (3, 3), (1, 2), (1, 4), (2, 5)]
```

## 제너레이터가 유용한 이유

이터레이터와 마찬가지로 제너레이터는 메모리를 절약한다.  
 제너레이터는 느리게 진전할 수 있으므로 작업에 필요한 데이터만 가져와서 메모리를 절약할 수 있다. 
 따라서 DB에서 큰 파일을 읽을 때 제너레이터를 사용해 메모리와 CPU 주기를 절약할 수 있다.    


 ## 리스트 컴프리헨션과 이터레이터
 리스트 컴프리헨션과 이터레이터는 숫자를 생성하는 두 가지 다른 방법이며, 숫자를 생성하는 동안 데이터를 메모리에 저장하거나 작업을 수행하는 방법에 큰 차이가 있다.  

 ```python
# 숫자를 200까지 생성하는 이터레이터 
(x*2 for x in xrange(200))
# 숫자를 200까지 생성하는 리스트 컴프리헨션
[x*2 for x in xrange(200)]
 ```
 위 코드에서 이터레이터와 리스트 컴프리헨션의 차이점은 후자의 경우 완료되면 200개의 숫자를 모두 메모리에 저장한다는 것이다.   
 하지만 이터레이터는 즉시 숫자를 생성하는 이터러블 객체를 생성하므로, 이터레이터의 경우 속도가 빠르다. 

 ## yield 키워드 활용
 yield는 함수가 제너레이터를 반환한다는 점을 제외하고 return과 같이 사용되는 키워드다  

 ```python
def generate_numbers(limit):
    for item in range(limit):
        yield item*item
        print(f"Inside the yield: {item}")

number = generate_number(3)
print(numbers)

for item in numbers:
    print(item)

<generator object generate_numbers at 0x000001C749429C80>
0
Inside the yield: 0
1
Inside the yield: 1
4
Inside the yield: 2
 ```

## yield from
yield from의 주요 사용은 다른 제너레이터에서 값을 얻는 것이다.  

```python
def flat_list(iter_values):
    """멀티 리스트나 그 외의 것을 펼친다."""
    for item in iter_values:
        if hasattr(item, '__iter__'):
            yield from flat_list(item))
        else:
            yield item

print(list(flat_list([1, [2], [3, [4]]])))
>>> [1, 2, 3, 4]
```
flat_list를 반복하는 대신 yield from을 사용해 라인을 단축한다.  

## 데이터 구조와 비교해 더 빠른 yield
많은 데이터를 처리하고 빠른 속도가 필요한 경우라면, 리스트나 튜플과 같은 데이터 구조에 의존하는 대신 제너레이터를 사용해 데이터를 생성해야 한다. 

```python
data = range(1000)
def using_yield():
    def wrapper():
        for d in data:
            yield d
    return list(wrapper())

def using_list():
    result = []
    for d in data:
        reslut.append(d)
    return result
```

두 코드 예제를 모두 실행하면 `yield`를 사용한 것이 확실히 빠르다.  

## 요약
제너레이터와 이터레이터는 특히 대량의 데이터나 큰 파일을 처리할 때 매우 유용하다. 하지만 과도하게 사용하면 메모리 누수와 같은 문제가 발생할 수 있으므로 주의하자.  