# 4장 모듈 및 메타클래스 작업

모듈과 메타프로그래밍을 잘 이해하면 좀 더 명확한 코드를 작성하는데 도움이 된다.   
파이썬의 메타클래스는 특정 용도로 사용할 때까지 신경 쓸 필요가 없는 일종의 숨겨진 기능이다.  
모듈은 코드/프로젝트를 구조화하고 코드를 구성하는 데 도움이 된다.  


## 모듈과 메타클래스
모듈은 단순히 `.py 확장자`를 가진 파이썬 파일이며, 모듈 이름이 곧 파일 이름이 될 것이다. 
모듈에는 여러 함수나 클래스가 있을 수 있다.

---
users/
users/payment.py
users/info.py

---
모듈은 코드를 좀 더 쉽게 구성할 수 있도록 도와준다.  

메타클래스는 간단히 말하면 클래스를 생성하는 청사진이라고 할 수 있다.  
클래스는 인스턴스를 생성하고, 메타클래스는 클래스를 생성할 때 필요한 것에 따라 클래스 동작을 자동으로 변경하는 데 도움이 된다.  

<br/>  

awesome으로 모듈의 모든 클래스를 생성해야 한다고 가정하자. 모듈 레벨에서 \__metaclass||를 사용해 수행할 수 있다.


```python
def awesome_attr(future_class_name, future_class_parents, future_class_attr):
    """
      awesome 키워드로 속성 접두사 리스트를 가진 클래스 객체를 반환한다.
    """
    # '__'으로 시작하지 않고 접두사가 awesome 인 attribution 선택.
    uppercase_attr = {}
    for name, val in future_class_attr.items():
        if not name.startswith('__'):
            uppercase_attr["_".join("awesome", name)] = val
        else:
            uppercase_attr[name] = val

    # type으로 클래스 생성
    return type(future_class_name, future_class_parents, uppercase_attr)


__metaclass__ = awesome_attr # 모듈의 모든 클래스에 영향을 미침


class Example: # global __metaclass__는 '객체'와 함께 작동하지 않을 것이다.
    # 그러나 이 클래스에만 영향을 미치도록 __metaclass__를 여기서 정의할 수 있다.
    # 그리고 '객체' 자식과 함께 작동할 것이다. 
    val = 'yes'
```
\__metaclass___는 여러 메타 클래스 개념 중 하나의 기능이다. 

## 모듈이 코드를 구성하는 데 도움이 되는 방법

모듈은 관련 함수, 변수, 클래스를 보유해 코드를 분리하는 데 도움이 된다. 다시 말해, 파이썬 모듈은 프로젝트의 여러 레이어를 여러 모듈에 배치해 추상화할 수 있는 도구를 제공한다.    

더 나은 모듈을 생성하는 데 도움이 되는 몇 가지 규칙을 살펴 보자.  
- 모듈 이름을 짧게 유지 

```python
# 추천하지 않는 방법:
import user_card_payment
import add_product_cart
from user import cards_payment

# 추천하는 방법
import payment
import cart
from user.cards import payment
```
- 점(.) 이나 대문자, 여러 특수 문자를 가진 이름은 피한다. 

```python
# 추천하지 않는 방법:
import user.card.payment
import USERS

# 추천하는 방법
import user_payment
import users
```
- 코드의 가독성을 고려할 때 특정 방식으로 모듈을 가져오는 것이 중요
```python
# 추천하지 않는 방법:
[...]
from user import *
[...]
cart = add_to_cart(4) # add_to_cart는 user의 일부인가? 내장형인가? 위에서 정의 했는가?

# 추천하는 방법
from user import add_to_cart
[...]
x = add_to_cart(4) # add_to_cart는 중간에 재정의 되지 않은 경우 user의 일부일 수 있다.

#더 추천하는 방법:
import user
[...]
x = user.add_to_cart(4) # add_to_cart는 보이는 것처럼 모듈 네임스페이스의 일부다.
```

모듈을 잘 활용하면 
1. 코드의 다른 부분에서 식별자 간의 충돌을 피하는 데 도움이 된다.
2. 하나의 모듈에서 상호 의존적인  코드를 분리해 이러한 경계를 정의하고 의존성을 최소화할 수 있다. 
3. 큰 문제를 더 작은 부분으로 나눌 수 있으므로 코드 작성이 훨씬 쉬워지고 다른 개발자가 더 읽기 쉽게 할 수 있다.
4. 프로젝트 내의 라이브러리와 API 같은 각기 다른 파일에서 쉽게 사용할 수 있다.

## 모듈의 함수와 클래스를 임포트하는 올바른 방법
파이썬에서 동일하거나 다른 모듈로부터 클래스와 함수를 임포트하는 방법은 여러가지가 있으며, 동일한 패키지 내에서 패키지를 임포트하거나 패키지 외부에서 패키지를 임포트할 수 있다. 두 시나리오를 살펴보고 모듈 내에서 클래스와 함수를 임포트하는 가장 좋은 방법을 알아보자.

- 패키지 내에서 동일한 패키지를 임포트하는 것은 완전히 지정된 경로나 상대 경로를 사용해 수행할 수 있다.

```python
# 추천하지 않는 방법
from foo import bar

# 추천하는 방법
from . import bar
```

첫 번째 import 구문은 TestPackage.Foo와 같이 패키지의 전체 경로를 사용하며 최상위 패키지의 이름이 소스 코드에 하드 코딩 됐다. 이 경우, 패지키 이름을 변경하거나 프로젝트의 디렉터리 구조를 재구성하려는 경우 문제가 발생한다.  

- 패키지 외부에서는 모듈 외부의 패키지를 임포트하는 여러 가지 방법이 있다.
```python
from mypackage import * # 나쁜 방법
from mypackage.test import bar # 괜찮은 방법
import mypackage # 추천하는 방법
```

두 번째 옵션은 어떤 패키지에서 임포트되는지 이해하는 데도 유용하다. 다른 개발자가 코드를 더 읽기 쉽게 만들어서 모든 의존성을 이해하는데 도움이 된다.  
하지만 다른 곳의 다른 패키지를 임포트할 때는 문제가 발생한다. 

<br/>  

세 번째 옵션을 추천하는 이유는 훨씬 더 읽기 쉽고 코드를 읽느 동안 어떤 클래스와 함수가 어떤 패키지에 속하는지 알 수 있기 때문이다. 

```python
import mypackage
import yourpackage
mypackage.foo.get_result()
yourpackage.foo.feed_data()
```

## \_\_all__을 사용한 임포트 방지

파이썬은 \_\_all__ 라는 특별한 메타클래스를 이용하여 임포트 동작을 제어할 수 있다.  
\_\_all__를 사용하면, counsumer class나 메서드가 모듈의 모든 항목 대신 특정 클래스나 특정 메서드만 임포트하도록 제한할 수 있다.   

```python
#payment.py

class A:
    ...

class B:
    ...

class C:
    ...

class D:
    ...

__all__ = ['A','C']
```
```python
from payment import *

class_A = A() # 정상 작동
class_B = B() # 에러 발생 
```

## 서브클래스 검증을 위한 \_\_new__사용

인스턴스를 생성할 때 마법 메스드 \_\_new__가 호출 될 것이다. 이 메서드를 사용하면 인스턴스 생성을 쉽게 사용자가 정의할 수 있다.   
이 메서드는 클래스의 인스턴스를 초기화하는 동안 \_\_init__를 호출하기 전에 호출 된다.   
  
super를 사용해 슈퍼클래스의 \_\_new__메서드를 호출함으로써 클래스의 새 인스턴스를 생성할 수 도 있다. 

```python
class User:
    def __new__(cls, *args, **kargs):
        print("Creating instaces")
        obj = super(User, cls).__new__(cls)
        return obj

    def  __init__(self, first_name, last_name):
        self.first_name = first_name
        self.last_name = last_name
    
    def full_name(self):
        return print(f"{self.first_name} {self.last_name}")

>> user = User("Larry","page")
Creating Instace
>> user.full_name()
Larry Page
```
여기서 클래스의 인스턴스를 생성하는 경우, \_\_init__ 마법 메서드를 호출하기 전에 \_\_new__가 호출 된다.

<br/>  

\_\_new__ 메타클래스를 사용해 서브클래스가 추상 클래스나 슈퍼크래스를 상속하기 전에 유효성을 검증할 수 있다.

```python
from abc import abstractmethod, ABCMeta

class UserAbstract(metaclass=ABCMeta):
    """__new__() 이니셜라이저를 사용해 팩토리 패턴을 구현하는 추상 기본 클래스 템플릿."""

    def __new__(cls, *args, **kwargs):
        """객체 인스턴스를 생성하고 기본 속성 설정"""
        obj = object.__new__(cls)
        obj.base_property = "Adding Property for each subclass"
        return obj


class User(UserAbstract):
    """UserAbstract 클래스를 구현하고 그 자신의 변수 추가."""

    def __init__(self):
        self.name = "Larry"


user = User()
user.name
# Larry
user.base_property
# Adding Property for each subclass
```
위 예제에서 base_property는 서브클래스를 위한 인스턴스가 생성될 때마다 `Adding Property for each subclass`값을 자동으로 얻는다.  

<br/>

제공된 값이 문자열인지 아닌지 확인하기 위해 위 코드를 수정해보자

```python
from abc import abstractmethod, ABCMeta


class UserAbstract(metaclass=ABCMeta):
    """__new__() 이니셜라이저를 사용해 팩토리 패턴을 구현하는 추상 기본 클래스 템플릿."""

    def __new__(cls, *args, **kwargs):
        """객체 인스턴스를 생성하고 기본 속성 설정"""
        obj = object.__new__(cls)
        given_data = args[0]
        # 여기서 데이터 유효성을 검증함.
        if not isinstance(given_data, str):
            raise ValueError(f"Please provide string: {given_data}")
        return obj


class User(UserAbstract):
    """UserAbstract 클래스를 구현하고 그 자신의 변수 추가."""

    def __init__(self, name):
        self.name = name


user = User(10)
# ValueError: Please provide string: 10
```

여기서 User 클래스를 위한 인스턴스를 생성하기 위해 값이 전달될 때마다 제공된 데이터가 문자열인지 확인한다.  

## \_\_slots__가 유용한 이유

\_\_slots__은 객체의 공간을 절약하고 더 빠르게 속성 액세스를 얻을 수 있다. 

```python
class WithSlots:
    """여기서 __slot__ masic을 사용한다."""
    __slots__ = "foo"


class WithoutSlots:
    """__slot__ 사용하지 않음"""
    pass


with_slots = WithSlots()
without_slots = WithoutSlots()


with_slots.foo = "Foo"
without_slots.foo = "Foo"


"""
>> %timeit with_slots.foo
44.5 ns
>> %timeit without_slots.foo
54.5 ns
"""
```
with_slots.foo에 단순히 액세스하려고 하는 경우 withouthSlots 클래스의 속성에 액세스하는 것보다 훨씬 빠르다.   
파이썬 3에서는 \_\_slots__를 사용하는것으 약 30% 빠름.  

또한 \_\_slots__는 각 객체 인스턴스가 차지하는 메모리 공간을 줄이는 데 도움이 됨.

