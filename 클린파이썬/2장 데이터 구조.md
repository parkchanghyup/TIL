# 2. 데이터 구조
데이터 구조는 모든 프로그래밍 언어의 기본 구성 요소다.  데이터 구조를 잘 이해하면, 많은 시간을 절약할 수 있고 데이터 구조를 사용해 코드를 유지할 수 있다.  
언제 어떤 데이터 구조를 사용해야 메모리, 사용 편의성, 코드 성능 측면에서 더 나은지 잘 이해하고 있어야 한다.  

## 공통 데이터 구조
파이썬에는 다양한 기본 데이터 구조가 있다.  이 절에서는 가장 일반적인 데이터 구조를 살펴본다.   
효율적인 코드를 작성하려면 데이터 구조의 개념을 잘 이해해야 한다.  

## 속도를 위한 set() 사용
`set()`은 파이썬의 기본 데이터 구조이며 한편으로는 가장 덜 사용되는 데이터 구조 이기도 하다.   
집합을 사용하면 얻게 되는 주요 이점은 속도이며, 특징은 다음과 같다.  

- 집합은 중복을 허용하지 않음
- 인덱싱 불가.
- 해시테이블을 사용하기 때문에 O(1) 시간 복잡도로 요소에 액세스 가능
- 슬라이싱과 lookup과 같은 일반적인 기능 사용 불가
- 삽입 시간에 요소를 정렬 할 수 있음.  

위와 같은 제약 조건을 잘 이해하면, 해당 기능들이 필요하지 않을때 집합을 사용해 더 빠른 속도로 데이터에 액세스 할 수 있다.  

```python
data = {'first', 'second','third','fourth','fifth'}
if 'fourth' in data:
    print('Found the Data')
```

수천 개의 항목이 있고 해당 요소의 항목에 자주 액세스해야 하는 경우, 리스트를 사용하는 대신 집합을 사용해 항목에 액세스 하는것이 더 빠르다.  
집합이 유용하고 데이터가 중복되지 않도록 하는 데 도움이 되는 예시를 살펴보자.

```python
data = ['first', 'second','third','fourth','fifth', 'second','third']
no_duplicate_data  = set(data)
>>>  {'first', 'second','third','fourth','fifth'}
```  
  
집합은 딕셔너리의 키로도 사용되며, 집합을 리스트와 같은 다른 데이터 구조의 키로 사용할 수 있다.   
  
ID 값을 키로 사용하고 사용자의 성과 이름을 값으로 갖는 데이터베이스의 딕셔너리를 가진 예제를 살펴보자.  

```python
user = {'1276' :{'first':'Larry','last':'Page'},
        '2343' : {'first' : 'John', 'last' : 'Freedom'}}

ids = set(users.keys())
full_names = []
for user in user.values():
    full_names.append(user['first'] + ' ' +user['last'])
```

## 데이터 반환 및 액세스를 위한 네임드튜플 사용
네임드튜플은 기본적으로 데이터의 이름을 가진 튜플이다.  
namedtuple은 튜플이 할 수 있는 것과 동일한 작업을 할 수 있지만, 튜플이 갖지 않는 몇 가지 추가 기능을 가진다.  
namedtuple을 사용하면 가변운 객체 타입을 쉽게 생성할 수 있다.   

### 데이터 액세스
namedtuple을 사용해 데이터에 액세스하면 훨씬 쉽게 읽을 수 있다. 초기화 후에 값이 변경되지 않는 클래스를 생성하는 예제를 살펴보자.   

```python
class Point:
    def __init__(self,x ,y ,z)
    self.x = x
    self.y = y
    self.z = z

point = Point(3, 4, 5)
point.x
point.y
point.z
```
Point 클래스의 값을 변경하지 않고, namedtuple을 사용한다면 아래 처럼 코드의 가독성이 더 좋아질 것이다.    
```python
from collections import namedtuple

Point = namedtuple("Point", ['x','y','z'])
point = Point(x = 3, y = 4, z= 5)

point.x
point.y
point.z
```
여기서 볼 수 있듯이, 이 코드는 일반 클래스를 사용하는 것보다 훨씬 더 읽기 쉽고 라인이 더 짧다.  
또한 namedtuple은 튜플과 동일한 메모리를 사용하므로 튜플만큼 성능이 좋다.  


### 데이터 반환
일반적으로 튜플로 데이터를 반한한다.  
한 함수에서 다른 함수로 데이터를 전달할 때마다 namedtuple 사용 가능 여부를 파악해야 함.  

```python
def get_user_info(User_obj):
    user = get_Data_from_db(user_obj)
    first_name = user['first_name']
    last_name = user['last_name]
    age  = user['age']
    return (first_name, last_name, age)

def get_full_name(first_name, last_name):
    return first_name + last_name

first_name, last_name, age = get_user_info(user_obj)
full_name = get_full_name(first_name, last_name)
```

위 함수의 문제점은 무엇인가? 문제는 값을 반환할 때 이다. 알다시피 데이터 베이스에서 가져온 후 사용자의 first_name, last_name, age 값을 반환한다. 
이제 이 값들을 get_full_name과 같은 다른 함수에 전달해야 한다고 생각했을때, 이 값들을 데이터 구조에 바인딩해  
추가 코드를 작성하지 않고 컨텍스트를 제공할 수 있다면 더 좋을 수 있다.  

```python
def get_user_info(user_obj):
    user = get_data_from_db(user_obj)
    UserInfo = namedtuple(“UserInfo”, [“first_name”, “last_name”, “age”])
    
    user_info = UserInfo(first_name=user[“first_name”],
                         last_name=user[“last_name”],
                         age=user[“age”])
    
    return user_info

def get_full_name(user_info):
    return user_info.first_name + user_info.last_name

user_info = get_user_info(user_obj)
full_name = get_full_name(user_info)
```
namedtuple을 사용해 코드를 작성하면 코드에 추가 정보를 제공하지 않아도 된다.  
여기서 user_info라는 namedtuple은 get_user_info라는 함수에서 반환될 때 명시적으로 설정하지 않고도 추가 컨텍스트를 제공한다.   
따라서 namedtuple을 사용하면 장기적으로 코드를 훨씬 읽기 쉽게 유지할 수 있다.  
<br/>  

열 개의 값을 반환한다면, 일반적으로 데이터를 이동하는 동안 tuple이나 dict의 사용을 고려할 수 있다.  
그러나 이 두 개의 구조는 데이터가 이동 중일 떄는 읽기가 쉽지 않다.  
튜플은 튜플의 데이터에 컨텍스트나 이름을 제공하지 않으며 dict는 불변성이 없으므로, 첫 번째 할당 후에 데이터를 변경하지 않으려는 제약을 받는다.  
**namedtuple은 tuple과 dict의 단점을 보완한다.**   

<br/>  

마지막으로 namedtuple을 dict로 변환 하거나, 리스트를 namedtuple로 변환한기 위한 메소드를 제공한다.  
다음에 불변 데이터를 가진 클래스를 만들거나 여러 값을 반환할 떄는 가독성과 유지보수성을 위해 namedtuple의 사용을 권장함.  

## 리스트 사용 시 주의 사항과 제너레이터 선호


이터레이터는 특히 많은 양의 데이터를 처리할 때 유용하다.  
시퀀스 데이터를 저장하기 위해 리스트를 사용한 코드를 살펴봤지만, 시스템의 성능에 영향을 줄 수 있는 `메모리 누수`의 위험이 있다.  


```python
def get_prime_numbers(lower,higher):
    primes = [] 
    for num in range(lower, higher + 1):
        for prime in range(2, num + 1):
            is_prime = True
            for item in range(2, int(num ** 0.5) + 1):
                if num %item ==0:
                    is_prime = False
                    break
        if is_prime:
            primes.append(num)
    return primes
print(get_prime_numbers(30,100))
```

    [31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
    

위와 같은 코드의 문제점은 무엇일까?   
1. 읽기가 어렵다.
2. 메모리에 많은 수를  저장하기 때문에 메모리 누수의 위험이 있다.  

가독성과 성능 측면에서 이 코드를 어떻게 개선할 수 있을까 ?  
여기서는 yield 키를 사용해 숫자를 생성하는 제너레이터 사용을 고려할 수 있고, 값을 표시하는 이터레이터로 사용할 수 있다. 이터레이터를 사용한 예제를 살펴보자.  


```python
import math

def is_prime(num):
    prime = True
    for item in range(2, int(math.sqrt(num)) + 1):
        if num % item == 0:
            prime = False
    return prime
    
def get_prime_numbers(lower, higher):
    for possible_prime in range(lower, higher):
        if is_prime(possible_prime):
            yield possible_prime
        yield False

for prime in get_prime_numbers(30, 50):
    if prime:
        print(prime)
```

    31
    37
    41
    43
    47
    

위 코드는 훨씬 읽기 쉽고 효율적이다.  
제너레이터를 사용하는 일반적인 사례 중 하나는 데이터베이스에서 데이터를 가져올때 가져올 행의 수를 모르는 경우 유용할 수 있다.  
메모리에 이러한 값을 저장하려고 할 때는 메모리를 많이 사용하는 작업일 수 있으며, 그 대신 이터레이터를 사용해 값을 즉시 반환하고 다음 행으로 이동함으로써 다음 값을 제공한다.  

ID로 사용자의 나이와 이름을 얻으려면 데이터 베이스에서 액세스 해야한다고 가정하자.   
데이터베이스 인덱스인 ID를 알고, 데이터베이스의 총 사용자 수가 1,000,000,000명 인 것을 안다.    



```python
# 데이터 베이스 액세스와 리스트 결과가 청크 저장

def get_all_users_age(total_users= 1000):
    age = []
    for id in range(total_users):
        user = acces_db_to_get_users_by_id(id)
        age.append([user.name, user.age])
    return age

total_suers = 100000000
info = get_all_users_age(total_users)
for user in info:
    print(user)
```

위 코드에서는 데이터베이스를 액세스해 사용자의 나이와 이름을 얻으려고 한다.   
그러나 사용자 정보를 저장하기 위해 메모리 안전을 고려한 숫자를 임의로 선택하기 때문에 시스테 메모리가 부족하면 이 접근은 좋지 않을 수 있다.   
파이썬에서는 이러한 문제를 피하고 코드에서 이러한 상황을 해결할 수 있는 수단으로 제너레이터를 활용한다.


```python
def get_all_users_age():
    all_users = 1000000000
    for id in range(all_users):
        user = acces_db_to_get_users_by_id(id)
        yield user.name, user.age
        
for user_name, user_age in get_all_users_age():
    print(user_name, user_age)
```

제너레이터는 데이터 집약적인 작업을 위해 고성능의 코드를 실행는 파이썬의 유용한 기능이다.

## 리스트 처리를 위한 zip 사용
두 개의 리스트가 있고 병렬로 처리 해야 한다면 zip를 사용하자. zip는 파이썬의 내장 함수 며 상당히 효율적이다.  

db의 사용자 테이블에 사용자 이름과 급여가 있다고 가정.  
이를 다른 리스트로 결합해 모든 사용자의 리스트로 반환하고자 함. 


```python
def get_user_salary_info():
    users = get_users_name_from_db()
    # ["Abe", "Larry", "Adams", "John", "Sumit", "Adward"]
    
    users_salary = get_users_salary_from_db()
    #  ["2M", "1M", "60K", "30K", "80K", "100K"]

    users_salary_info = []
    for index in range(len(users)):
        users_salay_info.append([users[index], users_salary[index]])
        
    return users_salary_info
```

위 문제를 zip 을 이용해 더 효율적으로 만들어 보자.


```python
def get_user_salary_info():
    users = get_users_name_from_db()
    # ["Abe", "Larry", "Adams", "John", "Sumit", "Adward"]
    
    users_salary = get_users_salary_from_db()
    #  ["2M", "1M", "60K", "30K", "80K", "100K"]

    users_salary_info = []
    for usr, sir in zip(users, suers_salary):
        users_salay_info.append([usr, slr])
        
    return users_salary_info
```

많은 데이터가 있는 경우 리스트에 저장하는 대신 이터레이터를 사용하는 것이 효율적이다.  
zip은 두 리스트를 결합하고 병렬로 쉽게 처리할 수 있으므로, zip을 사용하면 이러한 작업을 효율적으로 수행할 수 있다.  

## 딕셔너리의 장점

딕셔너리는 파이썬 에서 가장 많이 사용되는 데이터 구조 중 하나다. 딕셔너리는 데이터에 더 빠르게 액세스 할 수 있는 방법이다.  

## 컬렉션 
컬렉션은 파이썬에서 유용한 모듈 중 하나이다.  
collections에는 딕셔너리로 다른 작업을 수행하는 데 실제로 유용한 여러 인터페이스가 있음.  

<br/>   

**카운터**   

카운터는 유사한 데이터를 집계할 수 있는 편리한 방법을 제공한다.  

```python
from collections import Counter

contries  = ["Belarus", "Albania", "Malta", "Ukrain", "Belarus", "Malta", "Kosove", "Belarus"]
Counter(contries)
"""
>>> Counter({'Belarus': 3, 'Malta': 2, 'Albania': 1, 'Ukrain': 1, 'Kosove': 1})
"""
```

카운터는 dict의 서브 클래스다. 요소는 딕셔너리 키로 저장되고 갯수는 값으로 저장되는 order collection이며, 값의 개수를 계산하는 가장 효율적인 방법 중 하나다. 또한 카운터에는 most_common()이라는 유용한 메서드가 있다. 해당 메서든느 갯수의 수가 가장 많은 요소를 반환 한다.  

```python
from collections import Counter

contries  = ["Belarus", "Albania", "Malta", "Ukrain", "Belarus", "Malta", "Kosove", "Belarus"]
contries_count = Counter(contries)
"""
>>> Counter({'Belarus': 3, 'Malta': 2, 'Albania': 1, 'Ukrain': 1, 'Kosove': 1})
"""
contries_count.most_common(1)
"""
>>> [('Belarus', 3)]
"""
```

<br/>  

**deque**

<br/>  

큐와 스택을 생성하려면 deque를 사용하면 된다. deque를 이용해 오른쪽 혹은 왼쪽에서 값을 추가할 수 있다. deque는 양쪽에서 동일안 `O(1)` 성능으로, 메모리의 효율적인 추가 및 제거를 지원한다. 

```python
from collections import deque

# Make a deque
deq = deque("abcdefg")

# Iterate over the deque's element
deq = deque([item.upper() for item in deq])
# >>> deque(['A', 'B', 'C', 'D', 'E', 'F', 'G'])

# Add a new entry to right side
deq.append("h")
# >>> deque(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'h'])

# Add an new entry to the left side
deq.appendleft("I")
# >>> deque(['I', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'h'])

# Remove right most element
deq.pop()
# >>> 'h'

# Remove leftmost element
deq.popleft()
# >>> 'I'

# empty deque
deq.clear()
```

<br/>  

**defaultdict**  
   
   <br/>  

defaultdict는 dict의 서브클래스로 dict와 유사하게 작동한다. defaultdict는 인자가 없고 존재하지 않는  키의 기본값을 제공하는 `function("default factory")`로 초기화 된다. defaultdict는 dict와 같은 KeyError을 발생시키지 않는다. 존재하지 않는 키는 기본 값을 반환한다.



```python
from collections import defaultdict

# Make a defaultdict
langauge_found = defaultdict(int)

# Try printing value of non-existing key
langauge_found["golang"]
# >>> 0
```


<br/>  

**OrderedDict**

<br/>  


OrderedDict는 키를 특정 순서대로 가져오려고 하는 경우 사용할 수 있다. 

```python
from collections import OrderedDict

# Make a OrderedDict
colors = OrderedDict()

# Assing values
colors["orange"] = "ORANGE"
colors["blue"] = "BLUE"
colors["green"] = "GREEN"

# Get values
[k for k, v in colors.items()]
# >>> ['orange', 'blue', 'green']
```

## 두개의 딕셔너리를 병합하는 방법  

두 개의 딕셔너리를 병합하려고 한다. 데이터 구조를 병합하는 동안 메모리 사용과 데이터 손실에 주의해야 하므로 두 데이터 구조를 병합하는 것은 까다롭다. 추가 메모리를 사용해 병합된 데이터 구조를 저장하는 경우 딕셔너리의 데이터 크기를 고려해 시스템의 메모리 제한을 알아야 한다.  

데이터 손실도 한가지 고려 사항이다. 특정 데이터 구조의 제한으로 인해 일부 데이터가 손실될 여지가 있다. 예를 들어 딕셔너리는 중복 키를 가질 수 없다. 따라서 딕셔너리 간에 병합 작업을 수행할 때 이런 부분을 조심해야 한다.    

```python
salary_first = {"Lisa": 238900, "Ganesh": 8765000, "John": 3450000}
salary_second = {"Albert": 3456000, "Arya": 987600}
{**salary_first, **salary_second}

>>{"Lisa": 238900, "Ganesh": 8765000, "John": 3450000,"Albert": 3456000, "Arya": 987600}
```


