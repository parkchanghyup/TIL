# 2. 데이터 구조
데이터 구조는 모든 프로그래밍 언어의 기본 구성 요소다.  데이터 구조를 잘 이해하면, 많은 시간을 절약할 수 있고 데이터 구조를 사용해 코드를 유지할 수 있다.  
언제 어떤 데이터 구조를 사용해야 메모리, 사용 편의성, 코드 성능 측면에서 더 나은지 잘 이해하고 있어야 한다.  

## 공통 데이터 구조
파이썬에는 다양한 기본 데이터 구조가 있다.  이 절에서는 가장 일반적인 데이터 구조를 살펴본다.   
효율적인 코드를 작성하려면 데이터 구조의 개념을 잘 이해해야 한다.  

## 속도를 위한 set() 사용
`set()`은 파이썬의 기본 데이터 구조이며 한편으로는 가장 덜 사용되는 데이터 구조 이기도 하다.   
집합을 사용하면 얻게 되는 주요 이점은 속도이며, 특징은 다음과 같다.  

- 집합은 중복을 허용하지 않음
- 인덱싱 불가.
- 해시테이블을 사용하기 때문에 O(1) 시간 복잡도로 요소에 액세스 가능
- 슬라이싱과 lookup과 같은 일반적인 기능 사용 불가
- 삽입 시간에 요소를 정렬 할 수 있음.  

위와 같은 제약 조건을 잘 이해하면, 해당 기능들이 필요하지 않을때 집합을 사용해 더 빠른 속도로 데이터에 액세스 할 수 있다.  

```python
data = {'first', 'second','third','fourth','fifth'}
if 'fourth' in data:
    print('Found the Data')
```

수천 개의 항목이 있고 해당 요소의 항목에 자주 액세스해야 하는 경우, 리스트를 사용하는 대신 집합을 사용해 항목에 액세스 하는것이 더 빠르다.  
집합이 유용하고 데이터가 중복되지 않도록 하는 데 도움이 되는 예시를 살펴보자.

```python
data = ['first', 'second','third','fourth','fifth', 'second','third']
no_duplicate_data  = set(data)
>>>  {'first', 'second','third','fourth','fifth'}
```  
  
집합은 딕셔너리의 키로도 사용되며, 집합을 리스트와 같은 다른 데이터 구조의 키로 사용할 수 있다.   
  
ID 값을 키로 사용하고 사용자의 성과 이름을 값으로 갖는 데이터베이스의 딕셔너리를 가진 예제를 살펴보자.  

```python
user = {'1276' :{'first':'Larry','last':'Page'},
        '2343' : {'first' : 'John', 'last' : 'Freedom'}}

ids = set(users.keys())
full_names = []
for user in user.values():
    full_names.append(user['first'] + ' ' +user['last'])
```

## 데이터 반환 및 액세스를 위한 네임드튜플 사용
네임드튜플은 기본적으로 데이터의 이름을 가진 튜플이다.  
namedtuple은 튜플이 할 수 있는 것과 동일한 작업을 할 수 있지만, 튜플이 갖지 않는 몇 가지 추가 기능을 가진다.  
namedtuple을 사용하면 가변운 객체 타입을 쉽게 생성할 수 있다.   

### 데이터 액세스
namedtuple을 사용해 데이터에 액세스하면 훨씬 쉽게 읽을 수 있다. 초기화 후에 값이 변경되지 않는 클래스를 생성하는 예제를 살펴보자.   

```python
class Point:
    def __init__(self,x ,y ,z)
    self.x = x
    self.y = y
    self.z = z

point = Point(3, 4, 5)
point.x
point.y
point.z
```
Point 클래스의 값을 변경하지 않고, namedtuple을 사용한다면 아래 처럼 코드의 가독성이 더 좋아질 것이다.    
```python
from collections import namedtuple

Point = namedtuple("Point", ['x','y','z'])
point = Point(x = 3, y = 4, z= 5)

point.x
point.y
point.z
```
여기서 볼 수 있듯이, 이 코드는 일반 클래스를 사용하는 것보다 훨씬 더 읽기 쉽고 라인이 더 짧다.  
또한 namedtuple은 튜플과 동일한 메모리를 사용하므로 튜플만큼 성능이 좋다.  


### 데이터 반환
일반적으로 튜플로 데이터를 반한한다.  
한 함수에서 다른 함수로 데이터를 전달할 때마다 namedtuple 사용 가능 여부를 파악해야 함.  

```python
def get_user_info(User_obj):
    user = get_Data_from_db(user_obj)
    first_name = user['first_name']
    last_name = user['last_name]
    age  = user['age']
    return (first_name, last_name, age)

def get_full_name(first_name, last_name):
    return first_name + last_name

first_name, last_name, age = get_user_info(user_obj)
full_name = get_full_name(first_name, last_name)
```

위 함수의 문제점은 무엇인가? 문제는 값을 반환할 때 이다. 알다시피 데이터 베이스에서 가져온 후 사용자의 first_name, last_name, age 값을 반환한다. 
이제 이 값들을 get_full_name과 같은 다른 함수에 전달해야 한다고 생각했을때, 이 값들을 데이터 구조에 바인딩해  
추가 코드를 작성하지 않고 컨텍스트를 제공할 수 있다면 더 좋을 수 있다.  

```python
def get_user_info(user_obj):
    user = get_data_from_db(user_obj)
    UserInfo = namedtuple(“UserInfo”, [“first_name”, “last_name”, “age”])
    
    user_info = UserInfo(first_name=user[“first_name”],
                         last_name=user[“last_name”],
                         age=user[“age”])
    
    return user_info

def get_full_name(user_info):
    return user_info.first_name + user_info.last_name

user_info = get_user_info(user_obj)
full_name = get_full_name(user_info)
```
namedtuple을 사용해 코드를 작성하면 코드에 추가 정보를 제공하지 않아도 된다.  
여기서 user_info라는 namedtuple은 get_user_info라는 함수에서 반환될 때 명시적으로 설정하지 않고도 추가 컨텍스트를 제공한다.   
따라서 namedtuple을 사용하면 장기적으로 코드를 훨씬 읽기 쉽게 유지할 수 있다.  
<br/>  

열 개의 값을 반환한다면, 일반적으로 데이터를 이동하는 동안 tuple이나 dict의 사용을 고려할 수 있다.  
그러나 이 두 개의 구조는 데이터가 이동 중일 떄는 읽기가 쉽지 않다.  
튜플은 튜플의 데이터에 컨텍스트나 이름을 제공하지 않으며 dict는 불변성이 없으므로, 첫 번째 할당 후에 데이터를 변경하지 않으려는 제약을 받는다.  
**namedtuple은 tuple과 dict의 단점을 보완한다.**   

<br/>  

마지막으로 namedtuple을 dict로 변환 하거나, 리스트를 namedtuple로 변환한기 위한 메소드를 제공한다.  
다음에 불변 데이터를 가진 클래스를 만들거나 여러 값을 반환할 떄는 가독성과 유지보수성을 위해 namedtuple의 사용을 권장함.  
