# 정렬 알고리즘 이해하기  
빅데이터 시대에는 방대한 양의 데이터베이스를 빠르고 효율적으로 검색하는 기능이 필요하다.  
정렬 알고리즘은 도출하는 결과는 같더라도 알고리즘에 따라 성능과 효율이 달라질 수 있기 때문에[ 실제 문제에 적용하기 위해서는 알고리즘의 작동 원리와 장단점을 파악해야 한다.  
## 버블 정렬 
`버블 정렬`은 가장 간편하지만 속도가 느린 정렬 알고리즘이다.  최악의 경우에 버블 정렬의 시간 복잡도는 `$O(N^2)$`이므로 되도록 작은 데이터셋에만 사용하는 것이 좋다. 

### 버블 정렬 구현 코드
```python
sample = [25, 21, 22, 24, 23, 27, 26]
lastIdx = len(sample) - 1
print(0, sample)
for idx in range(lastIdx):
    if sample[idx] > sample[idx+1]:
        sample[idx], sample[idx+1] = sample[idx+1], sample[idx]
    print(idx+1, sample)
```
```
0 [25, 21, 22, 24, 23, 27, 26]
1 [21, 25, 22, 24, 23, 27, 26]
2 [21, 22, 25, 24, 23, 27, 26]
3 [21, 22, 24, 25, 23, 27, 26]
4 [21, 22, 24, 23, 25, 27, 26]
5 [21, 22, 24, 23, 25, 27, 26]
6 [21, 22, 24, 23, 25, 26, 27]
```

### 버블 정렬의 성능 분석
버블 정열은 두 개의 루프로 구성되어 있다.
- 외부 루프 : 패스를 의미한다. 예를 들어, 첫 번째 패스는 외부 루프를 처음 1회 실행하는 것과 같다.
- 내부 루프: 패스 내에서 가장 높은 값을 오른쪽으로 이동시킬 때까지 값들을 반복적으로 비교하는 과정이다. 첫 번째 패스는 총 $N-1$번을, 두 번째 패스는 $N-2$번을 반복하는 식으로 패스 횟수가 올라감에 따라 값을 비교하는 횟수가 하나씩 줄어든다.  

두 개의 루프가 중첩되어 있기 때문에 최악의 경우 버블 정렬의 시간 복잡도는 `$O(N^2)$` 이다.  

## 삽입 정렬
삽입 정렬의 기본 아이디어는 자료 구조에서 데이터 포인트를 하나씩 빼내에 올바른 위치에 집어넣는 과정을 반복하는 것이다.  
1. 맨 왼쪽에 위치한 두 데이터 포인트를 서로 비교하고 값의 크기에 따라 정렬
2. 그 다음 범위를 한 칸 확장하여 세 번째 데이터 포인트를 가져온다.
3. 앞 단계에서 정렬한 두개의 값을 이용해 세 번째 데이터 포인트의 적절한 위치를 결정
4. 반복

### 파이썬 코드
```python
def InsertionSort(sample):
    temp_list = []
    for i in range(1, len(sample)):
        j = i - 1
        temp = sample[i]
        while (sample[j] > temp) and j >=0 :
            sample[j+1] = sample[j]
            j = j-1
        sample[j+1] = temp
    return sample
sample = [25, 26, 22, 24, 27, 23, 21]
InsertionSort(sample)
print(sample)

# output
# [21, 22, 23, 24, 25, 26, 27]
```

### 삽입 정렬의 성능 분석
만약 대상 리스트가 이미 정렬된 상태라면 삽입 정렬의 시간 복잡도는 $O(N)$입니다. 그러나 그럴꺼면 쓸필요가 없겠죠? 
삽입 정렬의 최악의 경우는 $O(N^2)$입니다.  일반적으로 삽입 정렬은 크기가 매우 작은 정렬에 사용하는것이 좋습니다.    


## 병합 정렬 
병합 정렬은 맵리듀스와 같은 빅데이터 알고리즘처럼 분할 및 정복 전략을 사용합니다.  병합 정렬은 분리와 병합 두가지 과정을 이용하여 정렬을 하게 됩니다.
1. 분리(splitting) : 데이터를 재귀적으로 둘로 나눈다.
    - 분리 과정은 나뉜 부분의 크기가 미리 정한 기준보다 작아질 때까지 반복
2. 병합(merge) : 최종 결과를 얻을 때까지 알고리즘이 병합과 처리를 반복

### 병합 정렬 과정
1. 입력된 리스트를 크기가 같은 두 부분으로 나눈다
2. 나뉜 부분의 크기가 1이 될 때까지 반복해서 분리한다. 
3. 각 부분을 정렬한 뒤 병합하여 최종적으로 정려된 리스트를 반환한다.  


```python
def Mergesort(list):
    if len(list) > 1 :
        # 리스트를 반으로 나눔
        mid = len(list) // 2
        left_arr = list[:mid]
        right_arr = list[mid:]
        
        # 나늰 부분의 크끼가 1이 될 때까지 반복
        Mergesort(left_arr)
        Mergesort(right_arr)
        
        a = 0
        b = 0 
        c = 0
        
        while a < len(left_arr) and b < len(right_arr):
            if left_arr[a] < right_arr[b]:
                list[c] = left_arr[a]
                a = a + 1 
            else :
                list[c] = right_arr[b]
                b = b + 1
            c = c+1
            
        while a < len(left_arr):
            list[c] = left_arr[a]
            a = a + 1
            c = c + 1
            
        while b < len(right_arr):
            list[c] = right_arr[b]
            b = b + 1
            c = c + 1
            
    return list
list = [44, 16, 83, 2, 55, 10, 49, 85, 33]
Mergesort(list)    
# output
# [2, 10, 16, 33, 44, 49, 55, 83, 85]
```
