# 정렬 알고리즘 이해하기  
빅데이터 시대에는 방대한 양의 데이터베이스를 빠르고 효율적으로 검색하는 기능이 필요하다.  
정렬 알고리즘은 도출하는 결과는 같더라도 알고리즘에 따라 성능과 효율이 달라질 수 있기 때문에[ 실제 문제에 적용하기 위해서는 알고리즘의 작동 원리와 장단점을 파악해야 한다.  
## 버블 정렬 
`버블 정렬`은 가장 간편하지만 속도가 느린 정렬 알고리즘이다.  최악의 경우에 버블 정렬의 시간 복잡도는 `$O(N^2)$`이므로 되도록 작은 데이터셋에만 사용하는 것이 좋다. 

### 버블 정렬 구현 코드
```python
sample = [25, 21, 22, 24, 23, 27, 26]
lastIdx = len(sample) - 1
print(0, sample)
for idx in range(lastIdx):
    if sample[idx] > sample[idx+1]:
        sample[idx], sample[idx+1] = sample[idx+1], sample[idx]
    print(idx+1, sample)
```
```
0 [25, 21, 22, 24, 23, 27, 26]
1 [21, 25, 22, 24, 23, 27, 26]
2 [21, 22, 25, 24, 23, 27, 26]
3 [21, 22, 24, 25, 23, 27, 26]
4 [21, 22, 24, 23, 25, 27, 26]
5 [21, 22, 24, 23, 25, 27, 26]
6 [21, 22, 24, 23, 25, 26, 27]
```

### 버블 정렬의 성능 분석
버블 정열은 두 개의 루프로 구성되어 있다.
- 외부 루프 : 패스를 의미한다. 예를 들어, 첫 번째 패스는 외부 루프를 처음 1회 실행하는 것과 같다.
- 내부 루프: 패스 내에서 가장 높은 값을 오른쪽으로 이동시킬 때까지 값들을 반복적으로 비교하는 과정이다. 첫 번째 패스는 총 $N-1$번을, 두 번째 패스는 $N-2$번을 반복하는 식으로 패스 횟수가 올라감에 따라 값을 비교하는 횟수가 하나씩 줄어든다.  

두 개의 루프가 중첩되어 있기 때문에 최악의 경우 버블 정렬의 시간 복잡도는 `$O(N^2)$` 이다.  

## 삽입 정렬
삽입 정렬의 기본 아이디어는 자료 구조에서 데이터 포인트를 하나씩 빼내에 올바른 위치에 집어넣는 과정을 반복하는 것이다.  
1. 맨 왼쪽에 위치한 두 데이터 포인트를 서로 비교하고 값의 크기에 따라 정렬
2. 그 다음 범위를 한 칸 확장하여 세 번째 데이터 포인트를 가져온다.
3. 앞 단계에서 정렬한 두개의 값을 이용해 세 번째 데이터 포인트의 적절한 위치를 결정
4. 반복

### 파이썬 코드
```python
def InsertionSort(sample):
    temp_list = []
    for i in range(1, len(sample)):
        j = i - 1
        temp = sample[i]
        while (sample[j] > temp) and j >=0 :
            sample[j+1] = sample[j]
            j = j-1
        sample[j+1] = temp
    return sample
sample = [25, 26, 22, 24, 27, 23, 21]
InsertionSort(sample)
print(sample)

# output
# [21, 22, 23, 24, 25, 26, 27]
```

### 삽입 정렬의 성능 분석
만약 대상 리스트가 이미 정렬된 상태라면 삽입 정렬의 시간 복잡도는 $O(N)$입니다. 그러나 그럴꺼면 쓸필요가 없겠죠? 
삽입 정렬의 최악의 경우는 $O(N^2)$입니다.  일반적으로 삽입 정렬은 크기가 매우 작은 정렬에 사용하는것이 좋습니다.    


## 병합 정렬 
병합 정렬은 맵리듀스와 같은 빅데이터 알고리즘처럼 분할 및 정복 전략을 사용합니다.  병합 정렬은 분리와 병합 두가지 과정을 이용하여 정렬을 하게 됩니다.
1. 분리(splitting) : 데이터를 재귀적으로 둘로 나눈다.
    - 분리 과정은 나뉜 부분의 크기가 미리 정한 기준보다 작아질 때까지 반복
2. 병합(merge) : 최종 결과를 얻을 때까지 알고리즘이 병합과 처리를 반복

### 병합 정렬 과정
1. 입력된 리스트를 크기가 같은 두 부분으로 나눈다
2. 나뉜 부분의 크기가 1이 될 때까지 반복해서 분리한다. 
3. 각 부분을 정렬한 뒤 병합하여 최종적으로 정려된 리스트를 반환한다.  


```python
def Mergesort(list):
    if len(list) > 1 :
        # 리스트를 반으로 나눔
        mid = len(list) // 2
        left_arr = list[:mid]
        right_arr = list[mid:]
        
        # 나늰 부분의 크끼가 1이 될 때까지 반복
        Mergesort(left_arr)
        Mergesort(right_arr)
        
        a = 0
        b = 0 
        c = 0
        
        while a < len(left_arr) and b < len(right_arr):
            if left_arr[a] < right_arr[b]:
                list[c] = left_arr[a]
                a = a + 1 
            else :
                list[c] = right_arr[b]
                b = b + 1
            c = c+1
            
        while a < len(left_arr):
            list[c] = left_arr[a]
            a = a + 1
            c = c + 1
            
        while b < len(right_arr):
            list[c] = right_arr[b]
            b = b + 1
            c = c + 1
            
    return list
list = [44, 16, 83, 2, 55, 10, 49, 85, 33]
Mergesort(list)    
# output
# [2, 10, 16, 33, 44, 49, 55, 83, 85]
```
## 셀정렬
버블 정렬은 바로 인접한 이웃끼리 값을ㄹ 비교하여 순서를 맞춘다. 대상 리스트가 어느 정도 정렬된 상태라면, 루프 내에서 순서가 틀어진 이웃들이 없어지는 즉시 알고리즘이 종료되기 때문에 꽤 괜찮은 성능을 얻을 수 있다.   

그러나 전혀 정렬되지 않은 크기 N의 리스트에 버블 정렬을 사용한다면 N-1번의 패스르 수행해아 한다.  

<br/>    
셀 정렬은 바로 인접한 이웃 대신 고정된 거리만큼 서로 떨어진 데이터 포인트끼리 묶어 이들을 정렬한다.    
첫 번째 패스는 바로 인접한 이웃들이 아닌 고정된 거리만큼 떨어진 두 데이터 포인트를 비교하여 정렬한다.  
두 번째 패스는 네 개의 데이터 포인트로 구성된 하위 리스트를 정렬한다. 세 번째와 네 번째 패스는 하위 리스트에 담긴 데이터 포인트의 개수가 점차 증가하며, 하위 리스트의 개수는 줄어들게 된다.   
이 작업은 하나의 리스트에  모든 데이터 포인트가 들어갈 때까지 반복하다가 정렬 작업을 종료 한다.  

### 파이썬으로 구현한 셸 정렬

```python
def ShellSort(list):
    distance = len(list) // 2
    while distance > 0 :
        for i in range(distance, len(list)):
            temp = list[i]
            j = i
            # 하위 리스트 안에 든 요소들을 정렬
            while j >= distnace and list[j - distance] > temp:
                list[j] = list[j - distance]
                j = j-distance
            list[j] = temp
        # 다음 패스를 위해 거리를 반으로 줄인다.  
        distance = distance // 2
    return list
```

### 셸 정렬의 성능 분석
셸 정렬은 빅데이터보다는 중간 규모의 데이터셋에 적합하다. 최대 6,000개 요소가 담긴 리스트라면 셸 정렬이 꽤 괜찮은 성능을 발휘한다.  
리스트가 어느 정도 정렬된 상태라면 셸 정렬의 성능은 더욱 올라간다. 이미 정렬된 최상의 경우에는 N개의 요소를 각각 한 번씩 검사하면 작업이 끝나기 때문에 시간복잡도는 $O(N)$이다.  


## 선택정렬

선택 정렬은 필요한 교환 횟수를 최소화한 버블 정렬의 개량 버전이다.  버블 정렬에서는 각패스마다 가장 큰 값ㅇ을 한 칸씩 움직여 맨 오른쪽으로 이동시킨다.   따라서 크기가 N인 배열에서는 N-1번 교환이 발생한다.  
그러나 선택 정렬에서는 각 패스마다 가장 큰 값을 찾아내 맨 오른쪽으로 바로 이동시킨다.  

### 파이썬으로 구현한 선택 정렬
```python
def SelectionSort(list):
    for fill_slot in range(len(list) - 1, 0, -1):
        max_index = 0
        for location in range(1, fill_slot + 1):
            if list[location] > list[max_index]:
                max_index = location
        list[fill_slot], list[max_index] = list[max_index], list[fill_slot]
    return list
```

### 선택 정렬의 성능 분석
선택 정렬의 시간 복잡도는 최악의 경우 $O(N^2)$이다. 이는 버블 정렬의 성능과 비슷하기 때문에 ㅋ는 데이터셋에 사용하는 것은 피해야 한다.  
그러나 선택 정렬은 버블 정렬보다는 교환을 더 적게하기 때문에 성능은 더 뛰어 나다.   


